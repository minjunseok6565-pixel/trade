--- a/assets.py
+++ b/assets.py
@@ -1,23 +1,36 @@
 from __future__ import annotations
 
-"""
-assets.py
+"""assets.py
 
 Draft picks (and future asset types) live here.
 
-Design goals:
+Design goals
 - Store assets in GAME_STATE so they persist.
 - Provide stable IDs for assets (pick_id) so trades can reference them.
-- Keep protection representation simple-but-extensible.
+- Provide a *normalized* protection representation.
+
+Protection model (MVP+)
+- Internally we normalize protections to a `chain` list:
+
+    {
+      "chain": [
+        {"year": 2026, "type": "top_n", "n": 10},
+        {"year": 2027, "type": "none"}
+      ],
+      "convert_to": {"year": 2028, "round": 2}  # optional
+    }
+
+- This makes valuation logic deterministic and easy to extend.
+- We still accept legacy dict forms (e.g. {"type":"top_n","n":10,...}) and normalize them.
 
-This is an MVP draft. You will likely extend:
-- swaps, multi-year protections, convey/rollover rules
-- Stepien rule / pick trading restrictions
-- conditional second-rounders, cash considerations (if your game supports it)
+You will likely extend:
+- swaps
+- Stepien rule
+- multi-hop protection chains (we currently support up to ~3 hops cleanly)
 """
 
 from dataclasses import dataclass, asdict
-from typing import Any, Dict, List, Optional, Tuple
+from typing import Any, Dict, List, Optional
 import re
 
 try:
@@ -28,10 +41,12 @@
     def _ensure_league_state() -> Dict[str, Any]:
         return GAME_STATE.setdefault("league", {})
 
+
 # Optional: config provides authoritative team ids (preferred)
 def _all_team_ids() -> List[str]:
     try:
         from config import ALL_TEAM_IDS  # type: ignore
+
         return list(ALL_TEAM_IDS)
     except Exception:
         teams = GAME_STATE.get("teams")
@@ -46,16 +61,16 @@
 
 @dataclass(frozen=True)
 class DraftPick:
-    """
-    A tradable draft pick.
+    """A tradable draft pick.
 
     pick_id: stable identifier, stays the same even if current_owner changes
     season_year: draft year (e.g., 2026 draft)
     round: 1 or 2
     original_owner: team that originally "generated" this pick
     current_owner: team that currently owns the pick
-    protection: optional dict (e.g., {"type":"top_n","n":10,"conveys_to":"unprotected"})
+    protection: normalized protection dict (see module docstring) or None
     """
+
     pick_id: str
     season_year: int
     round: int
@@ -85,6 +100,7 @@
         return y
     try:
         from datetime import date
+
         return date.today().year
     except Exception:  # pragma: no cover
         return 2025
@@ -112,19 +128,153 @@
     }
 
 
-# ---- CRUD ----
+# ---------------------------------------------------------------------
+# Protection normalization
+# ---------------------------------------------------------------------
+
+def normalize_protection(protection: Optional[Dict[str, Any]], *, base_year: int) -> Optional[Dict[str, Any]]:
+    """Normalize a protection dict into the canonical `chain` format.
+
+    Accepts legacy forms:
+    - None
+    - {"type":"top_n","n":10}
+    - {"type":"top_n","n":10,"rollover": {"type":"none","year_offset":1}}
+    - {"chain":[...], "convert_to": {...}}
+
+    Returns None or a normalized dict with at least `chain`.
+    """
+
+    if not protection:
+        return None
+
+    if not isinstance(protection, dict):
+        return {"chain": [{"year": int(base_year), "type": "none"}]}
+
+    # Already normalized
+    if isinstance(protection.get("chain"), list):
+        chain_in = protection.get("chain") or []
+        chain: List[Dict[str, Any]] = []
+        for step in chain_in:
+            if not isinstance(step, dict):
+                continue
+            year = int(step.get("year", base_year) or base_year)
+            t = str(step.get("type", "none") or "none").lower()
+            if t in ("unprotected", "none", "unprot"):
+                chain.append({"year": year, "type": "none"})
+            elif t == "top_n":
+                n = int(step.get("n", 10) or 10)
+                n = max(1, min(30, n))
+                chain.append({"year": year, "type": "top_n", "n": n})
+            else:
+                chain.append({"year": year, "type": t})
+
+        if not chain:
+            chain = [{"year": int(base_year), "type": "none"}]
+
+        out: Dict[str, Any] = {"chain": chain}
+        if isinstance(protection.get("convert_to"), dict):
+            out["convert_to"] = dict(protection["convert_to"])
+        if isinstance(protection.get("notes"), str) and protection.get("notes"):
+            out["notes"] = str(protection.get("notes"))
+        return out
+
+    # Legacy {type: ...}
+    t = str(protection.get("type", "none") or "none").lower()
+    chain: List[Dict[str, Any]] = []
+
+    if t in ("unprotected", "none", "unprot", ""):
+        chain = [{"year": int(base_year), "type": "none"}]
+    elif t == "top_n":
+        n = int(protection.get("n", 10) or 10)
+        n = max(1, min(30, n))
+        chain.append({"year": int(base_year), "type": "top_n", "n": n})
+
+        # Rollover / conveys_to (optional)
+        rollover = protection.get("rollover")
+        conveys_to = protection.get("conveys_to")
+
+        if isinstance(rollover, dict):
+            yoff = int(rollover.get("year_offset", 1) or 1)
+            rt = str(rollover.get("type", "none") or "none").lower()
+            if rt in ("unprotected", "none", "unprot"):
+                chain.append({"year": int(base_year) + yoff, "type": "none"})
+            elif rt == "top_n":
+                rn = int(rollover.get("n", 10) or 10)
+                rn = max(1, min(30, rn))
+                chain.append({"year": int(base_year) + yoff, "type": "top_n", "n": rn})
+        elif isinstance(conveys_to, str) and conveys_to:
+            # Most common: conveys_to="unprotected" the next year
+            chain.append({"year": int(base_year) + 1, "type": "none"})
+
+    else:
+        # Unknown type (keep but mark)
+        chain = [{"year": int(base_year), "type": t}]
+
+    out2: Dict[str, Any] = {"chain": chain}
+    if isinstance(protection.get("convert_to"), dict):
+        out2["convert_to"] = dict(protection["convert_to"])
+    if isinstance(protection.get("notes"), str) and protection.get("notes"):
+        out2["notes"] = str(protection.get("notes"))
+    return out2
+
+
+def protection_chain(pick: DraftPick) -> List[Dict[str, Any]]:
+    """Return the canonical protection chain for a pick.
+
+    If pick.protection is None, returns [{"year": pick.season_year, "type": "none"}].
+    """
+
+    prot = normalize_protection(pick.protection, base_year=int(pick.season_year))
+    if not prot:
+        return [{"year": int(pick.season_year), "type": "none"}]
+    chain = prot.get("chain")
+    if isinstance(chain, list) and chain:
+        # Ensure sorted by year
+        chain2 = [dict(x) for x in chain if isinstance(x, dict)]
+        chain2.sort(key=lambda s: int(s.get("year", pick.season_year)))
+        return chain2
+    return [{"year": int(pick.season_year), "type": "none"}]
+
+
+# ---------------------------------------------------------------------
+# CRUD
+# ---------------------------------------------------------------------
+
 def get_pick(pick_id: str) -> Optional[DraftPick]:
     raw = _picks_store().get(str(pick_id))
     if not raw:
         return None
     try:
-        return DraftPick(**raw)  # type: ignore[arg-type]
+        p = DraftPick(**raw)  # type: ignore[arg-type]
+        # Normalize on the fly (do NOT mutate store here; keep idempotent)
+        prot = normalize_protection(p.protection, base_year=int(p.season_year))
+        return DraftPick(
+            pick_id=p.pick_id,
+            season_year=p.season_year,
+            round=p.round,
+            original_owner=str(p.original_owner).upper(),
+            current_owner=str(p.current_owner).upper(),
+            protection=prot,
+            notes=p.notes,
+        )
     except Exception:
         return None
 
 
 def upsert_pick(pick: DraftPick) -> None:
-    _picks_store()[str(pick.pick_id)] = asdict(pick)
+    # Ensure protection normalized before storing
+    prot = normalize_protection(pick.protection, base_year=int(pick.season_year))
+    _picks_store()[str(pick.pick_id)] = asdict(
+        DraftPick(
+            pick_id=str(pick.pick_id),
+            season_year=int(pick.season_year),
+            round=int(pick.round),
+            original_owner=str(pick.original_owner).upper(),
+            current_owner=str(pick.current_owner).upper(),
+            protection=prot,
+            notes=str(pick.notes or ""),
+        )
+    )
 
 
 def ensure_draft_picks_initialized(
@@ -133,14 +283,8 @@
     include_second_round: bool = True,
     force: bool = False,
 ) -> None:
-    """
-    Create a baseline set of picks for every team for upcoming drafts.
+    """Create a baseline set of picks for every team for upcoming drafts."""
 
-    By default:
-      - for each team, for each draft year in [season_year+1 .. season_year+num_future_years]
-      - create R1 (and R2 if enabled) picks
-      - all picks start unprotected (protection=None)
-    """
     store = _picks_store()
     if store and not force:
         return
@@ -153,32 +297,38 @@
     base_year = _league_season_year()
     for draft_year in range(base_year + 1, base_year + 1 + int(num_future_years)):
         for tid in teams:
+            tid_u = str(tid).upper()
             # Round 1
-            pid1 = make_pick_id(draft_year, 1, tid)
-            upsert_pick(DraftPick(
-                pick_id=pid1,
-                season_year=draft_year,
-                round=1,
-                original_owner=tid,
-                current_owner=tid,
-                protection=None,
-            ))
-            # Round 2
-            if include_second_round:
-                pid2 = make_pick_id(draft_year, 2, tid)
-                upsert_pick(DraftPick(
-                    pick_id=pid2,
+            pid1 = make_pick_id(draft_year, 1, tid_u)
+            upsert_pick(
+                DraftPick(
+                    pick_id=pid1,
                     season_year=draft_year,
-                    round=2,
-                    original_owner=tid,
-                    current_owner=tid,
+                    round=1,
+                    original_owner=tid_u,
+                    current_owner=tid_u,
                     protection=None,
-                ))
+                )
+            )
+            # Round 2
+            if include_second_round:
+                pid2 = make_pick_id(draft_year, 2, tid_u)
+                upsert_pick(
+                    DraftPick(
+                        pick_id=pid2,
+                        season_year=draft_year,
+                        round=2,
+                        original_owner=tid_u,
+                        current_owner=tid_u,
+                        protection=None,
+                    )
+                )
 
 
 def team_picks(team_id: str, *, only_owned: bool = True) -> List[DraftPick]:
     """Return picks where current_owner==team_id (default) or all picks involving team."""
-    team_id = str(team_id).upper()
+
+    team_id_u = str(team_id).upper()
     picks: List[DraftPick] = []
     for raw in _picks_store().values():
         try:
@@ -186,20 +336,18 @@
         except Exception:
             continue
         if only_owned:
-            if str(p.current_owner).upper() == team_id:
-                picks.append(p)
+            if str(p.current_owner).upper() == team_id_u:
+                picks.append(get_pick(p.pick_id) or p)
         else:
-            if str(p.current_owner).upper() == team_id or str(p.original_owner).upper() == team_id:
-                picks.append(p)
+            if str(p.current_owner).upper() == team_id_u or str(p.original_owner).upper() == team_id_u:
+                picks.append(get_pick(p.pick_id) or p)
     picks.sort(key=lambda x: (x.season_year, x.round, x.original_owner))
     return picks
 
 
 def transfer_pick(pick_id: str, new_owner: str, *, note: str = "") -> DraftPick:
-    """
-    Transfer ownership of a pick.
-    This function only updates the asset record; trade_engine should handle logs/roster rules.
-    """
+    """Transfer ownership of a pick."""
+
     existing = get_pick(pick_id)
     if not existing:
         meta = parse_pick_id(pick_id)
@@ -218,7 +366,7 @@
         pick_id=existing.pick_id,
         season_year=existing.season_year,
         round=existing.round,
-        original_owner=existing.original_owner,
+        original_owner=str(existing.original_owner).upper(),
         current_owner=str(new_owner).upper(),
         protection=existing.protection,
         notes=(note or existing.notes or ""),
@@ -228,13 +376,8 @@
 
 
 def set_pick_protection(pick_id: str, protection: Optional[Dict[str, Any]]) -> DraftPick:
-    """
-    Attach or clear protection metadata.
+    """Attach or clear protection metadata."""
 
-    Example protection dicts (recommended convention):
-      {"type":"top_n","n":10, "rollover": {"type":"unprotected", "year_offset":1}}
-      {"type":"lottery"}
-    """
     p = get_pick(pick_id)
     if not p:
         raise KeyError(f"Unknown pick_id: {pick_id}")
@@ -244,7 +387,7 @@
         round=p.round,
         original_owner=p.original_owner,
         current_owner=p.current_owner,
-        protection=protection,
+        protection=normalize_protection(protection, base_year=int(p.season_year)),
         notes=p.notes,
     )
     upsert_pick(updated)
@@ -252,22 +395,23 @@
 
 
 def describe_pick(pick: DraftPick) -> str:
+    chain = protection_chain(pick)
     prot = ""
-    if pick.protection:
-        t = str(pick.protection.get("type", "")).lower()
+    if chain:
+        first = chain[0]
+        t = str(first.get("type", "none") or "none").lower()
         if t == "top_n":
-            prot = f" (Top-{pick.protection.get('n')} protected)"
-        elif t:
+            prot = f" (Top-{first.get('n')} protected)"
+        elif t and t != "none":
             prot = f" ({t})"
-    rnd = "1st" if pick.round == 1 else "2nd"
-    return f"{pick.season_year} {rnd} (orig {pick.original_owner}){prot} -> owned by {pick.current_owner}"
+
+    rnd = "1st" if int(pick.round) == 1 else "2nd"
+    return f"{int(pick.season_year)} {rnd} (orig {str(pick.original_owner).upper()}){prot} -> owned by {str(pick.current_owner).upper()}"
 
 
 # ---- Rule helpers (placeholders) ----
+
 def is_stepien_legal(team_id: str, *, draft_year: int, outgoing_pick_ids: List[str]) -> bool:
-    """
-    Placeholder Stepien rule check.
-    MVP: always return True.
-    Later: disallow trading future 1st-rounders in consecutive years.
-    """
+    """Placeholder Stepien rule check. MVP: always return True."""
+
     return True
--- a/valuation.py
+++ b/valuation.py
@@ -1,52 +1,53 @@
 from __future__ import annotations
 
-"""
-valuation.py
+"""valuation.py
 
 Trade valuation layer.
 
-Key principle:
+Key principle
 - valuation.py produces numeric "utility/value" signals.
-- trade_engine.py (later) uses those values + rules to accept/decline/iterate offers.
+- trade_engine.py uses those values + rules to accept/decline/iterate offers.
+
+This module intentionally uses clear, debuggable heuristics. You'll tune it over time.
 
-This module is intentionally conservative: it uses simple heuristics with clear knobs,
-and relies on external context when available.
+This revision adds:
+- GM profiles (team meta -> gm_profile dict) and relationships scaffold
+- draft pick valuation using a probability distribution + protection "chain"
 
-Inputs it can consume:
-- GAME_STATE["players"][pid]  (from team_utils._init_players_and_teams_if_needed)
-- GAME_STATE["teams"][tid]    (tendency/window/market/patience)
-- contracts.get_contract(pid) (years_left, salary curve, etc.)
-- assets.get_pick(pick_id)    (draft pick metadata)
-- team_utils._evaluate_team_needs(...) output (status/need_positions/surplus_positions)
-
-You will likely expand:
-- a real projection model for pick ranges
-- better "fit" metrics using playstyle tags
-- market scarcity and deadline dynamics
+Notes
+- We try to avoid mutating state in valuation, but we *do* setdefault missing GM/relationship
+  fields because other modules depend on them being present.
 """
 
 from dataclasses import dataclass
 from typing import Any, Dict, List, Optional, Tuple
 
 import math
+import random
+import zlib
 
 try:
-    from state import GAME_STATE
+    from state import GAME_STATE, _ensure_league_state
 except Exception:  # pragma: no cover
     GAME_STATE: Dict[str, Any] = {"league": {}, "players": {}, "teams": {}}
 
+    def _ensure_league_state() -> Dict[str, Any]:
+        return GAME_STATE.setdefault("league", {})
+
 from contracts import ensure_contracts_initialized, salary_of_player, get_contract
-from assets import DraftPick, get_pick, ensure_draft_picks_initialized
+from assets import DraftPick, get_pick, ensure_draft_picks_initialized, protection_chain
 
 
-# -------------------------
-# Context models (lightweight)
-# -------------------------
+# ---------------------------------------------------------------------
+# Context models
+# ---------------------------------------------------------------------
+
 @dataclass(frozen=True)
 class MarketContext:
     """League-wide modifiers (scarcity, deadline, etc.)."""
-    deadline_pressure: float = 0.0   # 0..1 (0=none, 1=deadline day)
-    scarcity_by_role: Optional[Dict[str, float]] = None  # role -> premium multiplier
+
+    deadline_pressure: float = 0.0  # 0..1 (0=none, 1=deadline day)
+    scarcity_by_role: Optional[Dict[str, float]] = None
 
 
 @dataclass(frozen=True)
@@ -54,6 +55,8 @@
     team_id: str
     status: str  # contender | neutral | rebuild
     win_pct: float
+    games_played: int
+    point_diff: float
     need_positions: Tuple[str, ...]
     surplus_positions: Tuple[str, ...]
     gm_profile: Dict[str, Any]
@@ -72,18 +75,149 @@
     years_left: int
 
 
-# -------------------------
+# ---------------------------------------------------------------------
+# GM + relationship scaffolding
+# ---------------------------------------------------------------------
+
+_DEFAULT_GM_KEYS = (
+    "aggressiveness",
+    "risk_aversion",
+    "pick_hoarder",
+    "youth_bias",
+    "hardball",
+    "rival_penalty",
+    "trust_baseline",
+)
+
+
+def _stable_team_seed(team_id: str, *, global_seed: int = 0) -> int:
+    tid = str(team_id or "").upper().encode("utf-8")
+    return int(global_seed) ^ int(zlib.crc32(tid) & 0xFFFFFFFF)
+
+
+def ensure_gm_profiles_initialized(*, force: bool = False) -> None:
+    """Ensure GAME_STATE['teams'][tid]['gm_profile'] exists.
+
+    Creates deterministic pseudo-random profiles using league rng_seed (if any).
+    """
+
+    teams = GAME_STATE.get("teams")
+    if not isinstance(teams, dict):
+        return
+
+    league = _ensure_league_state()
+    global_seed = 0
+    if league.get("rng_seed") is not None:
+        try:
+            global_seed = int(league.get("rng_seed") or 0)
+        except Exception:
+            global_seed = 0
+
+    for tid, meta in teams.items():
+        if not isinstance(meta, dict):
+            continue
+        if ("gm_profile" in meta) and isinstance(meta.get("gm_profile"), dict) and not force:
+            # fill missing keys only
+            prof = meta["gm_profile"]
+            for k in _DEFAULT_GM_KEYS:
+                prof.setdefault(k, 0.5)
+            meta["gm_profile"] = prof
+            continue
+
+        rng = random.Random(_stable_team_seed(str(tid), global_seed=global_seed))
+        # Values are 0..1 but not extreme by default.
+        prof = {
+            "aggressiveness": float(rng.uniform(0.25, 0.75)),
+            "risk_aversion": float(rng.uniform(0.25, 0.75)),
+            "pick_hoarder": float(rng.uniform(0.20, 0.80)),
+            "youth_bias": float(rng.uniform(0.20, 0.80)),
+            "hardball": float(rng.uniform(0.25, 0.75)),
+            "rival_penalty": float(rng.uniform(0.30, 0.80)),
+            "trust_baseline": float(rng.uniform(0.40, 0.60)),
+        }
+        # Keep any existing patience key in the top-level meta (team_utils uses it)
+        meta.setdefault("patience", 0.5)
+        meta["gm_profile"] = prof
+
+
+def ensure_relationships_initialized(*, force: bool = False) -> None:
+    """Ensure GAME_STATE['relationships'][A][B] entries exist for all teams."""
+
+    ensure_gm_profiles_initialized()
+
+    rel = GAME_STATE.setdefault("relationships", {})
+    if not isinstance(rel, dict):
+        GAME_STATE["relationships"] = {}
+        rel = GAME_STATE["relationships"]
+
+    teams = GAME_STATE.get("teams")
+    if not isinstance(teams, dict) or not teams:
+        return
+
+    # rival heuristic: same division => rival
+    div_map: Dict[str, str] = {}
+    for tid, meta in teams.items():
+        if isinstance(meta, dict) and meta.get("division"):
+            div_map[str(tid).upper()] = str(meta.get("division"))
+
+    for a in teams.keys():
+        a_u = str(a).upper()
+        rel.setdefault(a_u, {})
+        if not isinstance(rel[a_u], dict):
+            rel[a_u] = {}
+        for b in teams.keys():
+            b_u = str(b).upper()
+            if a_u == b_u:
+                continue
+            if (not force) and isinstance(rel[a_u], dict) and isinstance(rel[a_u].get(b_u), dict):
+                # fill missing keys only
+                entry = rel[a_u][b_u]
+                entry.setdefault("trust", float(teams[a].get("gm_profile", {}).get("trust_baseline", 0.5)))
+                entry.setdefault("trade_count", 0)
+                entry.setdefault("last_trade_date", None)
+                entry.setdefault("rival", bool(div_map.get(a_u) and div_map.get(a_u) == div_map.get(b_u)))
+                continue
+
+            trust0 = float(teams[a].get("gm_profile", {}).get("trust_baseline", 0.5)) if isinstance(teams.get(a), dict) else 0.5
+            rel[a_u][b_u] = {
+                "trust": trust0,
+                "trade_count": 0,
+                "last_trade_date": None,
+                "rival": bool(div_map.get(a_u) and div_map.get(a_u) == div_map.get(b_u)),
+            }
+
+
+def get_relationship(team_id: str, other_team_id: str) -> Dict[str, Any]:
+    """Return relationship entry (ensuring it exists)."""
+
+    ensure_relationships_initialized()
+    rel = GAME_STATE.get("relationships")
+    if not isinstance(rel, dict):
+        return {"trust": 0.5, "trade_count": 0, "last_trade_date": None, "rival": False}
+    a = str(team_id).upper()
+    b = str(other_team_id).upper()
+    a_map = rel.get(a)
+    if not isinstance(a_map, dict):
+        return {"trust": 0.5, "trade_count": 0, "last_trade_date": None, "rival": False}
+    entry = a_map.get(b)
+    if not isinstance(entry, dict):
+        return {"trust": 0.5, "trade_count": 0, "last_trade_date": None, "rival": False}
+    return entry
+
+
+# ---------------------------------------------------------------------
 # Building contexts
-# -------------------------
+# ---------------------------------------------------------------------
+
 def build_team_contexts(*, force_recompute: bool = False) -> Dict[str, TeamContext]:
-    """
-    Build per-team context once and reuse during a trade tick.
+    """Build per-team context once and reuse during a trade tick."""
 
-    Uses team_utils helpers when available; otherwise falls back to GAME_STATE meta.
-    """
-    # Ensure state is at least initialized
+    ensure_gm_profiles_initialized()
+
+    # Use team_utils if available (records + needs)
     try:
         from team_utils import _init_players_and_teams_if_needed, _compute_team_records, _evaluate_team_needs
+
         _init_players_and_teams_if_needed()
         records = _compute_team_records()
         needs = _evaluate_team_needs(records)
@@ -93,22 +227,45 @@
 
     contexts: Dict[str, TeamContext] = {}
     teams_meta = GAME_STATE.get("teams") or {}
-    for tid, meta in (teams_meta.items() if isinstance(teams_meta, dict) else []):
+    if not isinstance(teams_meta, dict):
+        return contexts
+
+    for tid, meta in teams_meta.items():
         tid_u = str(tid).upper()
         need = needs.get(tid_u) or {}
-        status = str(need.get("status") or meta.get("tendency") or "neutral")
-        win_pct = float(need.get("win_pct") or 0.0)
+
+        rec = records.get(tid_u) or {}
+        wins = int(rec.get("wins", 0) or 0)
+        losses = int(rec.get("losses", 0) or 0)
+        gp = wins + losses
+        win_pct = float(need.get("win_pct") or (wins / gp if gp else 0.0))
+        pf = float(rec.get("pf", 0) or 0)
+        pa = float(rec.get("pa", 0) or 0)
+        point_diff = float(pf - pa)
+
+        status = str(need.get("status") or (meta.get("tendency") if isinstance(meta, dict) else None) or "neutral")
         need_pos = tuple(need.get("need_positions") or ())
         surplus_pos = tuple(need.get("surplus_positions") or ())
-        gm_profile = dict(meta) if isinstance(meta, dict) else {}
+
+        gm_profile = {}
+        if isinstance(meta, dict):
+            gp_meta = meta.get("gm_profile")
+            if isinstance(gp_meta, dict):
+                gm_profile = dict(gp_meta)
+            else:
+                gm_profile = {}
+
         contexts[tid_u] = TeamContext(
             team_id=tid_u,
-            status=status,
-            win_pct=win_pct,
+            status=str(status).lower(),
+            win_pct=float(win_pct),
+            games_played=int(gp),
+            point_diff=float(point_diff),
             need_positions=need_pos,
             surplus_positions=surplus_pos,
             gm_profile=gm_profile,
         )
+
     return contexts
 
 
@@ -135,26 +292,20 @@
     )
 
 
-# -------------------------
+# ---------------------------------------------------------------------
 # Core valuation functions
-# -------------------------
+# ---------------------------------------------------------------------
+
 def value_player_for_team(
     player_id: int,
     receiving_team_id: str,
     *,
     team_contexts: Optional[Dict[str, TeamContext]] = None,
     market: Optional[MarketContext] = None,
+    trade_partner_id: Optional[str] = None,
 ) -> float:
-    """
-    Returns a numeric value. Higher means more desirable for receiving_team_id.
+    """Return numeric value (higher = better) of player for receiving_team_id."""
 
-    This is intentionally simple (MVP):
-    - base: overall
-    - add: potential (more for rebuild teams)
-    - age curve: win-now prefers prime, rebuild prefers youth
-    - contract penalty/bonus (salary vs ovr, years_left)
-    - fit bonus if the player's position is in need_positions
-    """
     receiving_team_id = str(receiving_team_id).upper()
     ctxs = team_contexts or build_team_contexts()
     team_ctx = ctxs.get(receiving_team_id)
@@ -163,6 +314,8 @@
             team_id=receiving_team_id,
             status="neutral",
             win_pct=0.0,
+            games_played=0,
+            point_diff=0.0,
             need_positions=tuple(),
             surplus_positions=tuple(),
             gm_profile={},
@@ -172,19 +325,17 @@
     if not pctx:
         return 0.0
 
-    status = team_ctx.status
+    status = str(team_ctx.status or "neutral").lower()
 
     # --- Base basketball value ---
     v = float(pctx.overall)
 
     # --- Potential/age curves ---
-    if status == "contender":
+    if status.startswith("cont"):
         v += pctx.potential * 4.0
-        # Prime preference: 26-30
         v -= abs(pctx.age - 28) * 0.6
-    elif status == "rebuild":
+    elif status.startswith("reb"):
         v += pctx.potential * 8.0
-        # Youth preference: 19-24
         v -= max(0, pctx.age - 24) * 0.9
     else:
         v += pctx.potential * 6.0
@@ -193,12 +344,11 @@
     # --- Contract value (very rough) ---
     salary = float(salary_of_player(pctx.player_id))
     years_left = max(0, int(pctx.years_left))
-    # "Cost per OVR point" proxy; higher is worse
     cost_per_point = salary / max(1.0, pctx.overall)
-    v -= (cost_per_point / 1_000_000.0) * 0.9  # tune later
-    # Expiring premium: contenders like expirings a bit (flexibility); rebuilders don't mind longer if young
+    v -= (cost_per_point / 1_000_000.0) * 0.9
+
     if years_left <= 1:
-        v += 1.5 if status == "contender" else 0.5
+        v += 1.5 if status.startswith("cont") else 0.5
 
     # --- Fit bonus ---
     pos_group = _pos_group(pctx.pos)
@@ -207,10 +357,9 @@
     if pos_group and pos_group in team_ctx.surplus_positions:
         v -= 1.0
 
-    # --- GM personality nudge (uses existing team meta keys if present) ---
-    patience = float(team_ctx.gm_profile.get("patience", 0.5) or 0.5)
-    # Low patience teams overvalue immediate help
-    if status == "contender":
+    # --- GM personality nudge (still small; big levers live in trade_ai thresholds) ---
+    patience = float(GAME_STATE.get("teams", {}).get(receiving_team_id, {}).get("patience", 0.5) or 0.5)  # type: ignore[arg-type]
+    if status.startswith("cont"):
         v += (0.5 - patience) * 2.0
 
     # --- Market deadline pressure (small) ---
@@ -220,55 +369,178 @@
     return float(v)
 
 
+# -------------------------
+# Pick valuation (distribution + protection chain)
+# -------------------------
+
+def pick_position_distribution(
+    original_team_ctx: TeamContext,
+    *,
+    draft_year: int,
+) -> List[float]:
+    """Return probability distribution over pick number 1..30 for original_team in draft_year."""
+
+    # year_offset: 0 means next upcoming draft (league_season_year + 1)
+    base_draft_year = _league_season_year() + 1
+    year_offset = max(0, int(draft_year) - int(base_draft_year))
+
+    status = str(original_team_ctx.status or "neutral").lower()
+    tau = 2.0
+    if status.startswith("cont"):
+        tau = 3.0
+    elif status.startswith("reb"):
+        tau = 1.2
+
+    wp = max(0.0, min(1.0, float(original_team_ctx.win_pct)))
+    proj_win = 0.5 + (wp - 0.5) * math.exp(-float(year_offset) / max(0.5, tau))
+
+    mu = 1.0 + proj_win * 29.0  # high win -> later pick (near 30)
+
+    gp = max(0, int(original_team_ctx.games_played))
+    early_bonus = max(0.0, (20 - gp) * 0.08)
+
+    sigma = 3.5 + year_offset * 1.2 + early_bonus
+    sigma = max(1.8, float(sigma))
+
+    weights: List[float] = []
+    for k in range(1, 31):
+        z = (float(k) - mu) / sigma
+        weights.append(math.exp(-0.5 * z * z))
+
+    s = sum(weights)
+    if s <= 0:
+        return [1.0 / 30.0] * 30
+    return [w / s for w in weights]
+
+
+def _value_unprotected_from_dist(dist: List[float], *, round: int) -> float:
+    """Expected pick value from a distribution over 1..30."""
+
+    if not dist or len(dist) != 30:
+        return 0.0
+
+    v = 0.0
+    for i, p in enumerate(dist):
+        pick_num = i + 1
+        v += float(p) * _pick_value_from_expected_number(pick_num, round=round)
+    return float(v)
+
+
+def _conditional_tail(dist: List[float], start_pick_num: int) -> List[float]:
+    """Return conditional distribution for picks >= start_pick_num."""
+
+    start_pick_num = max(1, min(30, int(start_pick_num)))
+    idx = start_pick_num - 1
+    tail = dist[idx:]
+    s = sum(tail)
+    if s <= 1e-12:
+        # if tail is impossible, return a flat distribution on the tail domain
+        n = len(tail)
+        return [1.0 / max(1, n)] * n
+    return [x / s for x in tail]
+
+
 def value_pick_for_team(
     pick_id: str,
     receiving_team_id: str,
     *,
     team_contexts: Optional[Dict[str, TeamContext]] = None,
     market: Optional[MarketContext] = None,
+    trade_partner_id: Optional[str] = None,
 ) -> float:
+    """Value a draft pick for a receiving team.
+
+    This version:
+    - projects the original owner's pick range using a probability distribution
+    - applies protection chains via expectation over convey probability
+    - time-discounts future picks
+    - scales for team direction and GM preferences
     """
-    Value a draft pick for a receiving team.
-    Depends on:
-    - original owner's outlook (win_pct/status) -> expected pick range
-    - protection -> discount
-    - time discount for far future
-    - rebuild teams weight picks higher
-    """
+
     ensure_draft_picks_initialized()
     receiving_team_id = str(receiving_team_id).upper()
-    p = get_pick(pick_id)
-    if not p:
+
+    pick = get_pick(pick_id)
+    if not pick:
         return 0.0
 
     ctxs = team_contexts or build_team_contexts()
-    recv_ctx = ctxs.get(receiving_team_id)
-    if not recv_ctx:
-        recv_ctx = TeamContext(receiving_team_id, "neutral", 0.0, tuple(), tuple(), {})
-
-    orig_ctx = ctxs.get(str(p.original_owner).upper())
-    if not orig_ctx:
-        # fallback: use whatever team meta is available
-        orig_ctx = TeamContext(str(p.original_owner).upper(), "neutral", 0.5, tuple(), tuple(), {})
-
-    expected_pick = _expected_pick_number_from_win_pct(orig_ctx.win_pct)
-    base = _pick_value_from_expected_number(expected_pick, round=int(p.round))
-
-    # Protection discount
-    base *= _protection_multiplier(p.protection)
-
-    # Time discount
-    years_out = max(0, int(p.season_year) - (_league_season_year() + 1))
-    base *= (0.92 ** years_out)
+    recv_ctx = ctxs.get(receiving_team_id) or TeamContext(receiving_team_id, "neutral", 0.0, 0, 0.0, tuple(), tuple(), {})
+    orig_ctx = ctxs.get(str(pick.original_owner).upper()) or TeamContext(str(pick.original_owner).upper(), "neutral", 0.5, 0, 0.0, tuple(), tuple(), {})
 
-    # Team direction scaling (rebuild wants picks)
-    if recv_ctx.status == "rebuild":
+    chain = protection_chain(pick)
+    if not chain:
+        chain = [{"year": int(pick.season_year), "type": "none"}]
+
+    # chain length penalty (very small, keeps multi-hop protection from being overvalued)
+    chain_penalty = 0.97 ** max(0, len(chain) - 1)
+
+    reach_prob = 1.0
+    ev = 0.0
+
+    for step in chain:
+        year = int(step.get("year", pick.season_year) or pick.season_year)
+        year_offset = max(0, year - (_league_season_year() + 1))
+        dist = pick_position_distribution(orig_ctx, draft_year=year)
+        disc = 0.92 ** year_offset
+
+        t = str(step.get("type", "none") or "none").lower()
+        if t in ("none", "unprotected", "unprot"):
+            ev += reach_prob * disc * _value_unprotected_from_dist(dist, round=int(pick.round))
+            reach_prob = 0.0
+            break
+
+        if t == "top_n":
+            n = int(step.get("n", 10) or 10)
+            n = max(1, min(30, n))
+            p_protected = float(sum(dist[:n]))
+            p_convey = max(0.0, 1.0 - p_protected)
+
+            if p_convey > 1e-9:
+                tail_cond = _conditional_tail(dist, n + 1)  # distribution over (n+1..30)
+                # expand tail_cond back to len=30 for valuation helper
+                tail_dist = [0.0] * n + tail_cond
+                ev += reach_prob * p_convey * disc * _value_unprotected_from_dist(tail_dist, round=int(pick.round))
+
+            reach_prob *= p_protected
+            continue
+
+        # Unknown types: apply conservative discount and end.
+        ev += reach_prob * disc * _value_unprotected_from_dist(dist, round=int(pick.round)) * 0.75
+        reach_prob = 0.0
+        break
+
+    # If never conveys, apply convert_to if present
+    if reach_prob > 1e-9:
+        convert_to = pick.protection.get("convert_to") if isinstance(pick.protection, dict) else None
+        if isinstance(convert_to, dict):
+            cy = int(convert_to.get("year", pick.season_year + 1) or (pick.season_year + 1))
+            cr = int(convert_to.get("round", 2) or 2)
+            year_offset = max(0, cy - (_league_season_year() + 1))
+            disc = 0.92 ** year_offset
+            # approximate converted pick as a late-ish pick in that round
+            conv_val = _pick_value_from_expected_number(26, round=cr)
+            ev += reach_prob * disc * conv_val
+        else:
+            ev += reach_prob * 0.0
+
+    base = float(ev) * float(chain_penalty)
+
+    # Team direction scaling
+    status = str(recv_ctx.status or "neutral").lower()
+    if status.startswith("reb"):
         base *= 1.25
-    elif recv_ctx.status == "contender":
+    elif status.startswith("cont"):
         base *= 0.90
 
-    # Deadline pressure: contenders may pay more for "win-now" and less for picks
-    if market and recv_ctx.status == "contender":
+    # GM preferences (small but meaningful)
+    pick_hoarder = float(recv_ctx.gm_profile.get("pick_hoarder", 0.5) or 0.5)
+    youth_bias = float(recv_ctx.gm_profile.get("youth_bias", 0.5) or 0.5)
+    base *= (1.0 + (pick_hoarder - 0.5) * 0.30)
+    base *= (1.0 + (youth_bias - 0.5) * 0.12)
+
+    # Deadline pressure: contenders value picks slightly less near deadline
+    if market and status.startswith("cont"):
         base *= (1.0 - 0.05 * float(market.deadline_pressure))
 
     return float(base)
@@ -281,30 +553,30 @@
     pick_ids: Optional[List[str]] = None,
     team_contexts: Optional[Dict[str, TeamContext]] = None,
     market: Optional[MarketContext] = None,
+    trade_partner_id: Optional[str] = None,
 ) -> float:
     """Convenience: value a bundle of assets for a team."""
+
     total = 0.0
     for pid in (player_ids or []):
-        total += value_player_for_team(pid, receiving_team_id, team_contexts=team_contexts, market=market)
+        total += value_player_for_team(pid, receiving_team_id, team_contexts=team_contexts, market=market, trade_partner_id=trade_partner_id)
     for pk in (pick_ids or []):
-        total += value_pick_for_team(pk, receiving_team_id, team_contexts=team_contexts, market=market)
+        total += value_pick_for_team(pk, receiving_team_id, team_contexts=team_contexts, market=market, trade_partner_id=trade_partner_id)
     return float(total)
 
 
-# -------------------------
+# ---------------------------------------------------------------------
 # Internal helpers
-# -------------------------
+# ---------------------------------------------------------------------
+
 def _league_season_year() -> int:
-    try:
-        from state import _ensure_league_state
-        league = _ensure_league_state()
-        y = league.get("season_year")
-        if isinstance(y, int) and y > 0:
-            return y
-    except Exception:
-        pass
+    league = _ensure_league_state()
+    y = league.get("season_year")
+    if isinstance(y, int) and y > 0:
+        return y
     try:
         from datetime import date
+
         return date.today().year
     except Exception:  # pragma: no cover
         return 2025
@@ -312,58 +584,25 @@
 
 def _pos_group(pos: str) -> str:
     """Use the existing team_utils mapping if available; otherwise a simple fallback."""
+
     try:
         from team_utils import _position_group  # type: ignore
+
         return str(_position_group(pos))
     except Exception:
         p = str(pos).upper()
-        if "G" in p and "F" in p:
-            return "G"
-        if p.startswith("P") or "C" in p:
-            return "C"
-        if "F" in p:
-            return "F"
-        return "G"
-
+        if p in ("PG", "SG"):
+            return "guard"
+        if p in ("SF", "PF"):
+            return "wing"
+        return "big"
 
-def _expected_pick_number_from_win_pct(win_pct: float) -> int:
-    """
-    Rough mapping: win_pct -> expected pick number (1..30).
-    - win_pct 0.0 -> ~1
-    - win_pct 0.5 -> ~15-16
-    - win_pct 1.0 -> ~30
-    """
-    wp = max(0.0, min(1.0, float(win_pct)))
-    # invert: better team => later pick
-    pick = int(round(1 + wp * 29))
-    return max(1, min(30, pick))
 
+def _pick_value_from_expected_number(expected_pick: int, *, round: int = 1) -> float:
+    """Convert expected pick number into a value signal."""
 
-def _pick_value_from_expected_number(expected_pick: int, round: int = 1) -> float:
-    """
-    Convert expected pick number into a value signal.
-    Higher value for earlier picks. Round 2 is discounted.
-    """
     n = max(1, min(30, int(expected_pick)))
-    # convex curve: top picks are disproportionately valuable
     v = (31 - n) ** 1.15
     if int(round) == 2:
         v *= 0.35
     return float(v)
-
-
-def _protection_multiplier(protection: Optional[Dict[str, Any]]) -> float:
-    """Very rough discount for protected/conditional picks."""
-    if not protection:
-        return 1.0
-    t = str(protection.get("type", "")).lower()
-    if t == "top_n":
-        n = int(protection.get("n", 10) or 10)
-        n = max(1, min(30, n))
-        # more protection => less valuable
-        return float(max(0.35, 1.0 - (n / 30.0) * 0.8))
-    if t == "lottery":
-        return 0.65
-    if t == "heavily_protected":
-        return 0.45
-    return 0.75
--- a/trade_engine.py
+++ b/trade_engine.py
@@ -1,26 +1,22 @@
 from __future__ import annotations
 
-"""
-trade_engine.py
+"""trade_engine.py
 
 Core trade validation + application ("the referee + transaction applier").
 
-This module is designed to be:
+Design goals
 - deterministic given inputs (no random here)
 - reusable for BOTH AI trades and user-initiated trades
 - tolerant of partially-initialized state (early dev)
 
-It integrates with the existing codebase:
-- config.ROSTER_DF: canonical roster table (Team column is the owner team_id)
-- state.GAME_STATE: persistent state (players/teams/transactions)
-- contracts.py: salary + payroll helpers
-- assets.py: draft pick storage and ownership transfer
-
-This is an MVP draft. You will likely extend:
-- multi-team routing (3-team trades)
-- more NBA-like salary matching bands
-- Stepien rule, pick swaps, trade exceptions, hard-cap aprons
-- "trade block"/untouchables, no-trade clauses
+This revision adds (MVP+)
+- richer validation result fields (why it failed + numbers for auto-fixing)
+- human-readable explanation helper
+- fix suggestions helper for AI negotiation (salary filler / roster count)
+- relationship updates on successful trade
+
+NOTE
+- weekly news feed integration is kept, but the user asked to ignore weekly news changes.
 """
 
 from dataclasses import dataclass, asdict
@@ -43,19 +39,11 @@
         return GAME_STATE.setdefault("league", {})
 
 try:
-    from contracts import (
-        ensure_contracts_initialized,
-        salary_of_player,
-        total_salary,
-        team_payroll,
-    )
+    from contracts import ensure_contracts_initialized, total_salary, team_payroll
 except Exception:  # pragma: no cover
     def ensure_contracts_initialized(*args: Any, **kwargs: Any) -> None:
         return None
 
-    def salary_of_player(player_id: int, *args: Any, **kwargs: Any) -> float:
-        return 0.0
-
     def total_salary(player_ids: List[int], *args: Any, **kwargs: Any) -> float:
         return 0.0
 
@@ -63,23 +51,20 @@
         return 0.0
 
 try:
-    from assets import (
-        ensure_draft_picks_initialized,
-        get_pick,
-        transfer_pick,
-        describe_pick,
-    )
+    from assets import ensure_draft_picks_initialized, get_pick, transfer_pick, describe_pick, DraftPick
 except Exception:  # pragma: no cover
+    DraftPick = Any  # type: ignore
+
     def ensure_draft_picks_initialized(*args: Any, **kwargs: Any) -> None:
         return None
 
-    def get_pick(pick_id: str) -> Optional[Dict[str, Any]]:
+    def get_pick(pick_id: str) -> Optional[Any]:
         return None
 
-    def transfer_pick(pick_id: str, new_owner_team_id: str) -> Optional[Dict[str, Any]]:
+    def transfer_pick(pick_id: str, new_owner_team_id: str) -> Optional[Any]:
         return None
 
-    def describe_pick(pick: Dict[str, Any]) -> str:
+    def describe_pick(pick: Any) -> str:
         return str(pick)
 
 
@@ -93,6 +78,7 @@
 
     Outgoing lists are from each team to the other.
     """
+
     team_a: str
     team_b: str
     send_a_players: List[int]
@@ -106,13 +92,73 @@
 class TradeValidationResult:
     ok: bool
     reasons: List[str]
-    # Extra computed fields for logging/UI
+
+    # Date / deadline
+    date_str: Optional[str] = None
+    deadline: Optional[str] = None
+
+    # Roster counts
+    roster_a_before: int = 0
+    roster_b_before: int = 0
+    roster_a_after: int = 0
+    roster_b_after: int = 0
+
+    # Salary numbers
+    outgoing_salary_a: float = 0.0
+    outgoing_salary_b: float = 0.0
+    incoming_salary_a: float = 0.0
+    incoming_salary_b: float = 0.0
+    allowed_incoming_salary_a: float = 0.0
+    allowed_incoming_salary_b: float = 0.0
+
     payroll_a_before: float = 0.0
     payroll_b_before: float = 0.0
     payroll_a_after: float = 0.0
     payroll_b_after: float = 0.0
-    out_a: float = 0.0
-    out_b: float = 0.0
+
+    cap_space_a_before: float = 0.0
+    cap_space_b_before: float = 0.0
+
+    hard_cap_after_excess_a: float = 0.0
+    hard_cap_after_excess_b: float = 0.0
+
+    salary_over_amount_a: float = 0.0
+    salary_over_amount_b: float = 0.0
+
+    # Ownership / existence diagnostics
+    missing_players_a: List[int] = None  # type: ignore[assignment]
+    missing_players_b: List[int] = None  # type: ignore[assignment]
+    wrong_owner_players_a: List[int] = None  # type: ignore[assignment]
+    wrong_owner_players_b: List[int] = None  # type: ignore[assignment]
+
+    missing_picks_a: List[str] = None  # type: ignore[assignment]
+    missing_picks_b: List[str] = None  # type: ignore[assignment]
+    wrong_owner_picks_a: List[str] = None  # type: ignore[assignment]
+    wrong_owner_picks_b: List[str] = None  # type: ignore[assignment]
+
+    def __post_init__(self) -> None:
+        # normalize list fields
+        for k in (
+            "missing_players_a",
+            "missing_players_b",
+            "wrong_owner_players_a",
+            "wrong_owner_players_b",
+            "missing_picks_a",
+            "missing_picks_b",
+            "wrong_owner_picks_a",
+            "wrong_owner_picks_b",
+        ):
+            if getattr(self, k) is None:
+                setattr(self, k, [])
+
+
+@dataclass(frozen=True)
+class FixSuggestion:
+    kind: str
+    team_side: str  # "A" or "B"
+    amount: Optional[float] = None
+    notes: str = ""
+    constraints: Optional[Dict[str, Any]] = None
 
 
 # ---------------------------------------------------------------------
@@ -134,12 +180,12 @@
 def _league_rules() -> Dict[str, Any]:
     league = _ensure_league_state()
     rules = league.setdefault("trade_rules", {})
+
     # Defaults (kept simple and game-friendly)
     hard_cap = float(rules.get("hard_cap", HARD_CAP or 0.0))
     rules.setdefault("hard_cap", hard_cap)
 
     # If you don't model a "soft cap" yet, we still need a reference point for salary matching.
-    # Use a conservative default under the hard cap.
     rules.setdefault("soft_cap", float(rules.get("soft_cap", hard_cap * 0.85 if hard_cap else 0.0)))
 
     # Roster size bounds (NBA-ish, simplified)
@@ -149,6 +195,10 @@
     # Salary matching knobs (simplified)
     rules.setdefault("salary_match_pct_over_cap", float(rules.get("salary_match_pct_over_cap", 0.25)))  # 125%
     rules.setdefault("salary_match_bonus", float(rules.get("salary_match_bonus", 1_000_000.0)))  # +$1M buffer
+
+    # Optional deadline
+    # rules["trade_deadline"] = "YYYY-MM-DD"
+
     return rules
 
 
@@ -176,7 +226,6 @@
 
 
 def _player_name(player_id: int) -> str:
-    # prefer GAME_STATE meta
     meta = (GAME_STATE.get("players") or {}).get(int(player_id))
     if isinstance(meta, dict) and meta.get("name"):
         return str(meta["name"])
@@ -197,18 +246,68 @@
         items.append(item)
 
 
+def _ensure_relationship_slots(a: str, b: str) -> None:
+    """Create relationship entries if missing.
+
+    We keep this here (not valuation) because apply_trade must update trust/trade_count.
+    """
+
+    # Avoid importing valuation at module import time to prevent circular deps.
+    try:
+        import valuation
+
+        valuation.ensure_relationships_initialized()
+    except Exception:
+        # minimal fallback
+        rel = GAME_STATE.setdefault("relationships", {})
+        if not isinstance(rel, dict):
+            GAME_STATE["relationships"] = {}
+            rel = GAME_STATE["relationships"]
+        rel.setdefault(a, {})
+        rel.setdefault(b, {})
+        if isinstance(rel.get(a), dict):
+            rel[a].setdefault(b, {"trust": 0.5, "trade_count": 0, "last_trade_date": None, "rival": False})
+        if isinstance(rel.get(b), dict):
+            rel[b].setdefault(a, {"trust": 0.5, "trade_count": 0, "last_trade_date": None, "rival": False})
+
+
+def _update_relationships_after_trade(a: str, b: str, date_str: Optional[str]) -> None:
+    _ensure_relationship_slots(a, b)
+    rel = GAME_STATE.get("relationships")
+    if not isinstance(rel, dict):
+        return
+    for x, y in ((a, b), (b, a)):
+        m = rel.get(x)
+        if not isinstance(m, dict):
+            continue
+        entry = m.get(y)
+        if not isinstance(entry, dict):
+            entry = {"trust": 0.5, "trade_count": 0, "last_trade_date": None, "rival": False}
+            m[y] = entry
+        entry["trade_count"] = int(entry.get("trade_count", 0) or 0) + 1
+        entry["last_trade_date"] = date_str
+        # small trust bump for completed deals
+        try:
+            entry["trust"] = float(entry.get("trust", 0.5) or 0.5) + 0.01
+        except Exception:
+            entry["trust"] = 0.51
+        entry["trust"] = max(0.0, min(1.0, float(entry["trust"])))
+
+
 def _transaction_payload(
     proposal: TradeProposal,
     validation: TradeValidationResult,
     *,
     summary: str,
+    explain: Optional[Dict[str, Any]] = None,
+    evaluation: Optional[Dict[str, Any]] = None,
 ) -> Dict[str, Any]:
     a = _u(proposal.team_a)
     b = _u(proposal.team_b)
-    # Keep a modern structured payload, but also include legacy keys used by older UI/tools.
+
     return {
         "type": "trade",
-        "date": proposal.date_str or _now_date_str(),
+        "date": validation.date_str or proposal.date_str or _now_date_str(),
         # legacy
         "teams_involved": [a, b],
         "players_from_a": [int(x) for x in proposal.send_a_players],
@@ -224,27 +323,42 @@
             "b_picks": list(proposal.send_b_picks or []),
         },
         "salary": {
-            "a_out": validation.out_a,
-            "b_out": validation.out_b,
+            "a_out": validation.outgoing_salary_a,
+            "b_out": validation.outgoing_salary_b,
+            "a_in": validation.incoming_salary_a,
+            "b_in": validation.incoming_salary_b,
+            "a_allowed_in": validation.allowed_incoming_salary_a,
+            "b_allowed_in": validation.allowed_incoming_salary_b,
             "a_payroll_before": validation.payroll_a_before,
             "b_payroll_before": validation.payroll_b_before,
             "a_payroll_after": validation.payroll_a_after,
             "b_payroll_after": validation.payroll_b_after,
         },
+        "roster": {
+            "a_before": validation.roster_a_before,
+            "b_before": validation.roster_b_before,
+            "a_after": validation.roster_a_after,
+            "b_after": validation.roster_b_after,
+        },
+        "reasons": list(validation.reasons or []),
+        "validation": asdict(validation),
+        "explain": explain or {},
+        "evaluation": evaluation or {},
         "summary": summary,
     }
 
 
-
 # ---------------------------------------------------------------------
 # Validation
 # ---------------------------------------------------------------------
 
+
 def validate_trade(proposal: TradeProposal) -> TradeValidationResult:
     """Validate a two-team trade proposal.
 
     Returns a TradeValidationResult with ok=False and reasons if invalid.
     """
+
     ensure_contracts_initialized()
     ensure_draft_picks_initialized()
 
@@ -258,8 +372,24 @@
 
     a = _u(proposal.team_a)
     b = _u(proposal.team_b)
+
+    # normalize date
+    date_str = proposal.date_str or _now_date_str()
+
     reasons: List[str] = []
 
+    # Deadline guard (optional)
+    deadline = None
+    if rules.get("trade_deadline"):
+        deadline = str(rules.get("trade_deadline"))
+        if date_str:
+            try:
+                if date.fromisoformat(date_str) > date.fromisoformat(deadline):
+                    reasons.append("past_trade_deadline")
+            except Exception:
+                # ignore malformed deadline
+                pass
+
     if not a or not b:
         reasons.append("invalid_team_id")
     if a == b:
@@ -279,43 +409,74 @@
     if set(proposal.send_a_picks).intersection(set(proposal.send_b_picks)):
         reasons.append("same_pick_on_both_sides")
 
+    missing_players_a: List[int] = []
+    missing_players_b: List[int] = []
+    wrong_owner_players_a: List[int] = []
+    wrong_owner_players_b: List[int] = []
+
+    missing_picks_a: List[str] = []
+    missing_picks_b: List[str] = []
+    wrong_owner_picks_a: List[str] = []
+    wrong_owner_picks_b: List[str] = []
+
     # Ownership checks: players
     for pid in proposal.send_a_players:
         t = _player_team_from_roster(int(pid))
         if t is None:
-            reasons.append(f"unknown_player:{int(pid)}")
+            missing_players_a.append(int(pid))
         elif t != a:
-            reasons.append(f"player_not_on_team:{int(pid)}:{a}")
+            wrong_owner_players_a.append(int(pid))
+
     for pid in proposal.send_b_players:
         t = _player_team_from_roster(int(pid))
         if t is None:
-            reasons.append(f"unknown_player:{int(pid)}")
+            missing_players_b.append(int(pid))
         elif t != b:
-            reasons.append(f"player_not_on_team:{int(pid)}:{b}")
+            wrong_owner_players_b.append(int(pid))
+
+    if missing_players_a:
+        reasons.append("unknown_player_team_a")
+    if missing_players_b:
+        reasons.append("unknown_player_team_b")
+    if wrong_owner_players_a:
+        reasons.append("player_not_on_team_a")
+    if wrong_owner_players_b:
+        reasons.append("player_not_on_team_b")
 
     # Ownership checks: picks
     for pick_id in proposal.send_a_picks:
         p = get_pick(pick_id)
         if not p:
-            reasons.append(f"unknown_pick:{pick_id}")
+            missing_picks_a.append(str(pick_id))
             continue
-        owner = _u(str(p.get("owner_team_id", "")))
+        owner = _u(str(getattr(p, "current_owner", "")))
         if owner != a:
-            reasons.append(f"pick_not_owned_by_team:{pick_id}:{a}")
+            wrong_owner_picks_a.append(str(pick_id))
+
     for pick_id in proposal.send_b_picks:
         p = get_pick(pick_id)
         if not p:
-            reasons.append(f"unknown_pick:{pick_id}")
+            missing_picks_b.append(str(pick_id))
             continue
-        owner = _u(str(p.get("owner_team_id", "")))
+        owner = _u(str(getattr(p, "current_owner", "")))
         if owner != b:
-            reasons.append(f"pick_not_owned_by_team:{pick_id}:{b}")
+            wrong_owner_picks_b.append(str(pick_id))
+
+    if missing_picks_a:
+        reasons.append("unknown_pick_team_a")
+    if missing_picks_b:
+        reasons.append("unknown_pick_team_b")
+    if wrong_owner_picks_a:
+        reasons.append("pick_not_owned_by_team_a")
+    if wrong_owner_picks_b:
+        reasons.append("pick_not_owned_by_team_b")
 
     # Roster size after
     roster_a_before = _roster_count(a)
     roster_b_before = _roster_count(b)
     roster_a_after = roster_a_before - len(proposal.send_a_players) + len(proposal.send_b_players)
     roster_b_after = roster_b_before - len(proposal.send_b_players) + len(proposal.send_a_players)
+
     if roster_a_after < roster_min or roster_a_after > roster_max:
         reasons.append("roster_size_invalid_team_a")
     if roster_b_after < roster_min or roster_b_after > roster_max:
@@ -332,6 +493,12 @@
     payroll_a_after = payroll_a_before - out_a + in_a
     payroll_b_after = payroll_b_before - out_b + in_b
 
+    cap_space_a_before = max(0.0, soft_cap - payroll_a_before) if soft_cap else 0.0
+    cap_space_b_before = max(0.0, soft_cap - payroll_b_before) if soft_cap else 0.0
+
+    hard_excess_a = max(0.0, payroll_a_after - hard_cap) if hard_cap else 0.0
+    hard_excess_b = max(0.0, payroll_b_after - hard_cap) if hard_cap else 0.0
+
     # Hard cap check
     if hard_cap:
         if payroll_a_after > hard_cap:
@@ -349,8 +516,11 @@
             return 0.0
         return outgoing * (1.0 + pct_over) + bonus
 
-    allowed_a = allowed_incoming(payroll_a_before, out_a)
-    allowed_b = allowed_incoming(payroll_b_before, out_b)
+    allowed_a = float(allowed_incoming(payroll_a_before, out_a))
+    allowed_b = float(allowed_incoming(payroll_b_before, out_b))
+
+    over_a = max(0.0, in_a - allowed_a)
+    over_b = max(0.0, in_b - allowed_b)
 
     if in_a - 1e-6 > allowed_a:
         reasons.append("salary_match_failed_team_a")
@@ -361,36 +531,247 @@
     return TradeValidationResult(
         ok=ok,
         reasons=reasons,
+        date_str=date_str,
+        deadline=deadline,
+        roster_a_before=roster_a_before,
+        roster_b_before=roster_b_before,
+        roster_a_after=roster_a_after,
+        roster_b_after=roster_b_after,
+        outgoing_salary_a=out_a,
+        outgoing_salary_b=out_b,
+        incoming_salary_a=in_a,
+        incoming_salary_b=in_b,
+        allowed_incoming_salary_a=allowed_a,
+        allowed_incoming_salary_b=allowed_b,
         payroll_a_before=payroll_a_before,
         payroll_b_before=payroll_b_before,
         payroll_a_after=payroll_a_after,
         payroll_b_after=payroll_b_after,
-        out_a=out_a,
-        out_b=out_b,
+        cap_space_a_before=cap_space_a_before,
+        cap_space_b_before=cap_space_b_before,
+        hard_cap_after_excess_a=hard_excess_a,
+        hard_cap_after_excess_b=hard_excess_b,
+        salary_over_amount_a=over_a,
+        salary_over_amount_b=over_b,
+        missing_players_a=missing_players_a,
+        missing_players_b=missing_players_b,
+        wrong_owner_players_a=wrong_owner_players_a,
+        wrong_owner_players_b=wrong_owner_players_b,
+        missing_picks_a=missing_picks_a,
+        missing_picks_b=missing_picks_b,
+        wrong_owner_picks_a=wrong_owner_picks_a,
+        wrong_owner_picks_b=wrong_owner_picks_b,
     )
 
 
 # ---------------------------------------------------------------------
+# Explain + fix suggestions (G)
+# ---------------------------------------------------------------------
+
+
+def explain_validation(proposal: TradeProposal, validation: TradeValidationResult, *, locale: str = "ko") -> Dict[str, Any]:
+    """Turn a validation result into human-friendly explanation.
+
+    Returns a dict with {summary, details, codes}.
+    """
+
+    a = _u(proposal.team_a)
+    b = _u(proposal.team_b)
+
+    codes = list(validation.reasons or [])
+    details: List[str] = []
+
+    def ko(s: str, en: str) -> str:
+        return s if str(locale).lower().startswith("ko") else en
+
+    if not codes:
+        return {
+            "summary": ko(" .", "Trade is valid."),
+            "details": [],
+            "codes": [],
+        }
+
+    # Summary: first major reason
+    primary = codes[0]
+    summary_map = {
+        "past_trade_deadline": ko("  .", "Trade deadline has passed."),
+        "salary_match_failed_team_a": ko(f"   ({a})", f"Salary match failed ({a})"),
+        "salary_match_failed_team_b": ko(f"   ({b})", f"Salary match failed ({b})"),
+        "roster_size_invalid_team_a": ko(f"    ({a})", f"Roster size invalid ({a})"),
+        "roster_size_invalid_team_b": ko(f"    ({b})", f"Roster size invalid ({b})"),
+        "hard_cap_exceeded_team_a": ko(f"  ({a})", f"Hard cap exceeded ({a})"),
+        "hard_cap_exceeded_team_b": ko(f"  ({b})", f"Hard cap exceeded ({b})"),
+        "unknown_player_team_a": ko(f"({a})     .", f"Unknown player(s) on {a} side."),
+        "unknown_player_team_b": ko(f"({b})     .", f"Unknown player(s) on {b} side."),
+        "player_not_on_team_a": ko(f"({a})     .", f"Player not owned by {a}."),
+        "player_not_on_team_b": ko(f"({b})     .", f"Player not owned by {b}."),
+        "unknown_pick_team_a": ko(f"({a})     .", f"Unknown pick(s) on {a} side."),
+        "unknown_pick_team_b": ko(f"({b})     .", f"Unknown pick(s) on {b} side."),
+        "pick_not_owned_by_team_a": ko(f"({a})     .", f"Pick not owned by {a}."),
+        "pick_not_owned_by_team_b": ko(f"({b})     .", f"Pick not owned by {b}."),
+    }
+
+    summary = summary_map.get(primary) or ko("  .", "Trade is invalid.")
+
+    # Details
+    if "past_trade_deadline" in codes and validation.deadline:
+        details.append(ko(f": {validation.deadline}", f"Deadline: {validation.deadline}"))
+
+    if "salary_match_failed_team_a" in codes:
+        details.append(
+            ko(
+                f"{a} incoming {validation.incoming_salary_a:,.0f} > allowed {validation.allowed_incoming_salary_a:,.0f} ( {validation.salary_over_amount_a:,.0f})",
+                f"{a} incoming {validation.incoming_salary_a:,.0f} > allowed {validation.allowed_incoming_salary_a:,.0f} (over {validation.salary_over_amount_a:,.0f})",
+            )
+        )
+    if "salary_match_failed_team_b" in codes:
+        details.append(
+            ko(
+                f"{b} incoming {validation.incoming_salary_b:,.0f} > allowed {validation.allowed_incoming_salary_b:,.0f} ( {validation.salary_over_amount_b:,.0f})",
+                f"{b} incoming {validation.incoming_salary_b:,.0f} > allowed {validation.allowed_incoming_salary_b:,.0f} (over {validation.salary_over_amount_b:,.0f})",
+            )
+        )
+
+    if "roster_size_invalid_team_a" in codes:
+        details.append(ko(f"{a} roster {validation.roster_a_before} -> {validation.roster_a_after}", f"{a} roster {validation.roster_a_before} -> {validation.roster_a_after}"))
+    if "roster_size_invalid_team_b" in codes:
+        details.append(ko(f"{b} roster {validation.roster_b_before} -> {validation.roster_b_after}", f"{b} roster {validation.roster_b_before} -> {validation.roster_b_after}"))
+
+    if "hard_cap_exceeded_team_a" in codes:
+        details.append(ko(f"{a}  : {validation.hard_cap_after_excess_a:,.0f}", f"{a} hard cap excess: {validation.hard_cap_after_excess_a:,.0f}"))
+    if "hard_cap_exceeded_team_b" in codes:
+        details.append(ko(f"{b}  : {validation.hard_cap_after_excess_b:,.0f}", f"{b} hard cap excess: {validation.hard_cap_after_excess_b:,.0f}"))
+
+    if validation.missing_players_a:
+        details.append(ko(f"{a} missing players: {validation.missing_players_a}", f"{a} missing players: {validation.missing_players_a}"))
+    if validation.wrong_owner_players_a:
+        details.append(ko(f"{a} wrong-owner players: {validation.wrong_owner_players_a}", f"{a} wrong-owner players: {validation.wrong_owner_players_a}"))
+    if validation.missing_players_b:
+        details.append(ko(f"{b} missing players: {validation.missing_players_b}", f"{b} missing players: {validation.missing_players_b}"))
+    if validation.wrong_owner_players_b:
+        details.append(ko(f"{b} wrong-owner players: {validation.wrong_owner_players_b}", f"{b} wrong-owner players: {validation.wrong_owner_players_b}"))
+
+    if validation.missing_picks_a:
+        details.append(ko(f"{a} missing picks: {validation.missing_picks_a}", f"{a} missing picks: {validation.missing_picks_a}"))
+    if validation.wrong_owner_picks_a:
+        details.append(ko(f"{a} wrong-owner picks: {validation.wrong_owner_picks_a}", f"{a} wrong-owner picks: {validation.wrong_owner_picks_a}"))
+    if validation.missing_picks_b:
+        details.append(ko(f"{b} missing picks: {validation.missing_picks_b}", f"{b} missing picks: {validation.missing_picks_b}"))
+    if validation.wrong_owner_picks_b:
+        details.append(ko(f"{b} wrong-owner picks: {validation.wrong_owner_picks_b}", f"{b} wrong-owner picks: {validation.wrong_owner_picks_b}"))
+
+    return {
+        "summary": summary,
+        "details": details,
+        "codes": codes,
+    }
+
+
+def suggest_fixes(proposal: TradeProposal, validation: TradeValidationResult) -> List[FixSuggestion]:
+    """Return fix suggestions that an AI can try automatically."""
+
+    fixes: List[FixSuggestion] = []
+    codes = set(validation.reasons or [])
+
+    # Salary fixes
+    if "salary_match_failed_team_a" in codes:
+        fixes.append(
+            FixSuggestion(
+                kind="add_outgoing_salary",
+                team_side="A",
+                amount=float(validation.salary_over_amount_a),
+                notes="Add outgoing salary (salary filler) from Team A.",
+            )
+        )
+    if "salary_match_failed_team_b" in codes:
+        fixes.append(
+            FixSuggestion(
+                kind="add_outgoing_salary",
+                team_side="B",
+                amount=float(validation.salary_over_amount_b),
+                notes="Add outgoing salary (salary filler) from Team B.",
+            )
+        )
+
+    # Roster size fixes
+    if "roster_size_invalid_team_a" in codes:
+        if validation.roster_a_after > validation.roster_a_before:
+            fixes.append(FixSuggestion(kind="add_outgoing_player", team_side="A", amount=1.0, notes="Roster too big: send one more player from Team A."))
+        else:
+            fixes.append(FixSuggestion(kind="reduce_outgoing", team_side="A", amount=1.0, notes="Roster too small: reduce outgoing players from Team A."))
+
+    if "roster_size_invalid_team_b" in codes:
+        if validation.roster_b_after > validation.roster_b_before:
+            fixes.append(FixSuggestion(kind="add_outgoing_player", team_side="B", amount=1.0, notes="Roster too big: send one more player from Team B."))
+        else:
+            fixes.append(FixSuggestion(kind="reduce_outgoing", team_side="B", amount=1.0, notes="Roster too small: reduce outgoing players from Team B."))
+
+    # Ownership / existence: safest fix is to remove the offending asset(s)
+    if validation.missing_players_a or validation.wrong_owner_players_a:
+        fixes.append(
+            FixSuggestion(
+                kind="remove_asset",
+                team_side="A",
+                notes="Remove missing/wrong-owner player(s) from Team A outgoing.",
+                constraints={"player_ids": list(set(validation.missing_players_a + validation.wrong_owner_players_a))},
+            )
+        )
+    if validation.missing_players_b or validation.wrong_owner_players_b:
+        fixes.append(
+            FixSuggestion(
+                kind="remove_asset",
+                team_side="B",
+                notes="Remove missing/wrong-owner player(s) from Team B outgoing.",
+                constraints={"player_ids": list(set(validation.missing_players_b + validation.wrong_owner_players_b))},
+            )
+        )
+    if validation.missing_picks_a or validation.wrong_owner_picks_a:
+        fixes.append(
+            FixSuggestion(
+                kind="remove_asset",
+                team_side="A",
+                notes="Remove missing/wrong-owner pick(s) from Team A outgoing.",
+                constraints={"pick_ids": list(set(validation.missing_picks_a + validation.wrong_owner_picks_a))},
+            )
+        )
+    if validation.missing_picks_b or validation.wrong_owner_picks_b:
+        fixes.append(
+            FixSuggestion(
+                kind="remove_asset",
+                team_side="B",
+                notes="Remove missing/wrong-owner pick(s) from Team B outgoing.",
+                constraints={"pick_ids": list(set(validation.missing_picks_b + validation.wrong_owner_picks_b))},
+            )
+        )
+
+    # Keep it short (AI can call validate again and iterate)
+    return fixes[:4]
+
+
+# ---------------------------------------------------------------------
 # Apply
 # ---------------------------------------------------------------------
 
+
 def apply_trade(
     proposal: TradeProposal,
     *,
     record_transaction: bool = True,
     record_weekly_news: bool = True,
+    evaluation: Optional[Dict[str, Any]] = None,
 ) -> TradeValidationResult:
     """Apply a validated trade to ROSTER_DF and GAME_STATE.
 
     Raises ValueError if invalid.
     """
+
     validation = validate_trade(proposal)
     if not validation.ok:
         raise ValueError(f"Invalid trade: {validation.reasons}")
 
     a = _u(proposal.team_a)
     b = _u(proposal.team_b)
-    date_str = proposal.date_str or _now_date_str()
+    date_str = validation.date_str or proposal.date_str or _now_date_str()
 
     # Update ROSTER_DF Team ownership (canonical roster table)
     if ROSTER_DF is not None:
@@ -422,8 +803,9 @@
     # Create summary string
     a_names = ", ".join(_player_name(pid) for pid in proposal.send_a_players) if proposal.send_a_players else ""
     b_names = ", ".join(_player_name(pid) for pid in proposal.send_b_players) if proposal.send_b_players else ""
-    a_picks = ", ".join(describe_pick(get_pick(pid) or {"pick_id": pid}) for pid in proposal.send_a_picks) if proposal.send_a_picks else ""
-    b_picks = ", ".join(describe_pick(get_pick(pid) or {"pick_id": pid}) for pid in proposal.send_b_picks) if proposal.send_b_picks else ""
+
+    a_picks = ", ".join(describe_pick(get_pick(pid) or DraftPick(pid, 0, 1, "", "")) for pid in proposal.send_a_picks) if proposal.send_a_picks else ""
+    b_picks = ", ".join(describe_pick(get_pick(pid) or DraftPick(pid, 0, 1, "", "")) for pid in proposal.send_b_picks) if proposal.send_b_picks else ""
 
     def join_bits(parts: List[str]) -> str:
         parts2 = [p for p in parts if p]
@@ -433,8 +815,10 @@
     if date_str:
         summary = f"[{date_str}] " + summary
 
+    explain = explain_validation(proposal, validation, locale="ko")
+
     if record_transaction:
-        tx = _transaction_payload(proposal, validation, summary=summary)
+        tx = _transaction_payload(proposal, validation, summary=summary, explain=explain, evaluation=evaluation)
         GAME_STATE.setdefault("transactions", [])
         if isinstance(GAME_STATE["transactions"], list):
             GAME_STATE["transactions"].append(tx)
@@ -447,9 +831,13 @@
             "teams": [a, b],
         })
 
+    # Relationship update
+    _update_relationships_after_trade(a, b, date_str)
+
     return validation
 
 
 def proposal_to_dict(proposal: TradeProposal) -> Dict[str, Any]:
     """Useful for API responses / logging."""
+
     return asdict(proposal)
--- a/trade_ai.py
+++ b/trade_ai.py
@@ -1,30 +1,28 @@
 from __future__ import annotations
 
-"""
-trade_ai.py
+"""trade_ai.py
 
 AI trade orchestrator.
 
-Responsibilities:
+Responsibilities
 - decide "when" to run (tick cadence + deadline guard)
 - generate candidate trade proposals between AI-controlled teams
 - evaluate acceptability using valuation.py
 - validate+apply using trade_engine.py
 
-Important design choice:
-- trade_ai.py does NOT mutate state directly (except via trade_engine.apply_trade).
-- keep valuation separate (valuation.py) so you can tune without touching the engine.
-
-This is an MVP draft. You will likely extend:
-- 2-for-1, 3-team, pick swaps
-- richer needs/fit/contract logic
-- negotiation (counteroffers)
-- market dynamics (deadline premium, scarcity)
+This revision upgrades the AI from a single "1-for-1 plus maybe picks" heuristic to:
+- template-based proposal generation (1-for-1, 2-for-1, 1-for-1 + pick)
+- simple negotiation (up to 2 counters)
+- automatic rule-fix attempts using trade_engine.suggest_fixes (salary filler / roster)
+- GM profiles + relationships affecting acceptance thresholds
+
+It is still intentionally lightweight (fast + deterministic enough for a sim loop).
 """
 
 from dataclasses import dataclass
 from datetime import date
 from typing import Any, Dict, List, Optional, Sequence, Tuple
+import math
 import random
 
 try:
@@ -52,14 +50,19 @@
             return "wing"
         return "big"
 
-from contracts import ensure_contracts_initialized, salary_of_player, team_payroll
-from assets import ensure_draft_picks_initialized, team_picks
+from contracts import ensure_contracts_initialized, salary_of_player
+from assets import ensure_draft_picks_initialized, team_picks, DraftPick
 import valuation
-from trade_engine import TradeProposal, validate_trade, apply_trade
+from trade_engine import (
+    TradeProposal,
+    validate_trade,
+    apply_trade,
+    suggest_fixes,
+)
 
 
 # ---------------------------------------------------------------------
-# Tuning knobs (reasonable defaults)
+# Tuning knobs
 # ---------------------------------------------------------------------
 
 @dataclass
@@ -68,26 +71,38 @@
     max_trades_per_tick: int = 3
 
     # Candidate generation
-    sellers_per_buyer: int = 4
-    targets_per_pair: int = 3
-    outgoing_candidates: int = 8
+    sellers_per_buyer: int = 5
+    targets_per_pair: int = 4
+
+    outgoing_single_candidates: int = 10
+    outgoing_pair_pool: int = 8
+    proposals_per_pair_cap: int = 25
 
-    # Decision thresholds (net utility)
+    # Negotiation
+    max_counter_rounds: int = 2
+    max_picks_in_offer: int = 2
+    allow_young_sweetener: bool = True
+
+    # Decision thresholds (base net utility)
     min_net_contender: float = 1.0
     min_net_neutral: float = 0.5
     min_net_rebuild: float = 0.3
 
-    # Allow AI to include up to N picks to sweeten a deal
-    max_picks_in_offer: int = 2
-
     # Avoid too many blockbuster deals in one tick
-    max_star_ovr: float = 89.0  # if you don't want AI to constantly trade superstars
+    max_star_ovr: float = 89.0
+
+    # Validation-fix safety
+    max_fix_attempts_per_proposal: int = 1
 
 
 def _u(x: str) -> str:
     return str(x or "").upper().strip()
 
 
+# ---------------------------------------------------------------------
+# League timing / market context
+# ---------------------------------------------------------------------
+
 def _past_deadline(today: date) -> bool:
     league = _ensure_league_state()
     rules = league.get("trade_rules") or {}
@@ -118,8 +133,29 @@
     league["last_gm_tick_date"] = today.isoformat()
 
 
+def _market_context(today: date) -> valuation.MarketContext:
+    league = _ensure_league_state()
+    rules = league.get("trade_rules") or {}
+    dl = rules.get("trade_deadline")
+    if not dl:
+        return valuation.MarketContext(deadline_pressure=0.0)
+    try:
+        dl_d = date.fromisoformat(str(dl))
+    except Exception:
+        return valuation.MarketContext(deadline_pressure=0.0)
+
+    # Simple pressure curve: 0 at 60+ days out, 1 at deadline day
+    days_left = (dl_d - today).days
+    pressure = 1.0 - (max(0, min(60, days_left)) / 60.0)
+    pressure = max(0.0, min(1.0, float(pressure)))
+    return valuation.MarketContext(deadline_pressure=pressure)
+
+
+# ---------------------------------------------------------------------
+# Team pools / thresholds
+# ---------------------------------------------------------------------
+
 def _teams_for_ai(user_team_id: Optional[str]) -> List[str]:
-    # Prefer TEAM meta in GAME_STATE via valuation contexts
     ctx = valuation.build_team_contexts()
     ids = sorted(ctx.keys())
     if user_team_id:
@@ -127,7 +163,7 @@
     return ids
 
 
-def _threshold_for(status: str, tuning: AITuning) -> float:
+def _base_threshold_for(status: str, tuning: AITuning) -> float:
     s = str(status or "neutral").lower()
     if s.startswith("cont"):
         return tuning.min_net_contender
@@ -136,6 +172,62 @@
     return tuning.min_net_neutral
 
 
+def threshold_for_team(
+    team_ctx: valuation.TeamContext,
+    *,
+    partner_id: str,
+    market: valuation.MarketContext,
+    direction: str,
+    tuning: AITuning,
+) -> float:
+    """Acceptance threshold for *net* value.
+
+    Higher threshold => more demanding.
+
+    direction
+    - "buy": team is trying to acquire a target
+    - "sell": team is giving up the target
+    """
+
+    base = float(_base_threshold_for(team_ctx.status, tuning))
+
+    prof = team_ctx.gm_profile or {}
+    hardball = float(prof.get("hardball", 0.5) or 0.5)
+    aggressiveness = float(prof.get("aggressiveness", 0.5) or 0.5)
+    pick_hoarder = float(prof.get("pick_hoarder", 0.5) or 0.5)
+
+    # personality
+    base *= (1.0 + (hardball - 0.5) * 0.6)
+
+    # situation
+    if str(direction) == "buy" and str(team_ctx.status) == "contender":
+        base *= (1.0 - aggressiveness * 0.25)
+    if str(direction) == "sell" and str(team_ctx.status) == "rebuild":
+        base *= (1.0 + pick_hoarder * 0.20)
+
+    # relationship / rival
+    rel = valuation.get_relationship(team_ctx.team_id, partner_id)
+    trust = float(rel.get("trust", 0.5) or 0.5)
+    rival = bool(rel.get("rival", False))
+    rival_pen = float(prof.get("rival_penalty", 0.5) or 0.5)
+
+    base *= (1.0 + (0.5 - trust) * 0.8)
+    if rival:
+        base += 0.2 * rival_pen
+
+    # market
+    if str(team_ctx.status) == "contender" and str(direction) == "buy":
+        base *= (1.0 - 0.20 * float(market.deadline_pressure))
+    if str(team_ctx.status) == "rebuild" and str(direction) == "sell":
+        base *= (1.0 + 0.20 * float(market.deadline_pressure))
+
+    return float(base)
+
+
+# ---------------------------------------------------------------------
+# Roster helpers
+# ---------------------------------------------------------------------
+
 def _roster_df(team_id: str):
     if ROSTER_DF is None:
         return None
@@ -146,24 +238,23 @@
 
 
 def _candidate_targets(seller_id: str, buyer_ctx: valuation.TeamContext, *, tuning: AITuning) -> List[int]:
+    """From seller roster, return a shortlist of players buyer might want."""
+
     df = _roster_df(seller_id)
     if df is None or df.empty:
         return []
 
     need_pos = set(buyer_ctx.need_positions or ())
-    # Prefer players that match buyer needs
+
     def score_row(row) -> float:
-        ovr = float(row.get("OVR", 0.0))
+        ovr = float(row.get("OVR", 0.0) or 0.0)
         age = float(row.get("Age", 0.0) or 0.0)
-        # if position group matches need, boost
         pos_g = _position_group(str(row.get("POS", "")))
         need_bonus = 3.0 if (need_pos and pos_g in need_pos) else 0.0
-        # avoid constant superstar swaps unless you want that chaos
         superstar_penalty = 5.0 if ovr >= tuning.max_star_ovr else 0.0
         return ovr + need_bonus - 0.05 * age - superstar_penalty
 
-    # Take top-K by heuristic score
-    rows = []
+    rows: List[Tuple[float, int]] = []
     for pid, row in df.iterrows():
         try:
             rows.append((float(score_row(row)), int(pid)))
@@ -173,54 +264,155 @@
     return [pid for _, pid in rows[: int(tuning.targets_per_pair)]]
 
 
-def _candidate_outgoing_players(buyer_id: str, target_salary: float, buyer_ctx: valuation.TeamContext, *, tuning: AITuning) -> List[int]:
+def _candidate_outgoing_singles(
+    buyer_id: str,
+    target_salary: float,
+    buyer_ctx: valuation.TeamContext,
+    *,
+    tuning: AITuning,
+) -> List[int]:
+    """Outgoing single-player candidates from buyer.
+
+    Heuristic: surplus position, low OVR, and salary that can help matching.
+    """
+
     df = _roster_df(buyer_id)
     if df is None or df.empty:
         return []
 
     surplus = set(buyer_ctx.surplus_positions or ())
-    # Heuristic: prefer surplus-position players, low OVR, and salary similar to target
-    rows = []
+
+    rows: List[Tuple[float, int]] = []
     for pid, row in df.iterrows():
         try:
             pid_i = int(pid)
-            ovr = float(row.get("OVR", 0.0))
+            ovr = float(row.get("OVR", 0.0) or 0.0)
             pos_g = _position_group(str(row.get("POS", "")))
             sal = float(salary_of_player(pid_i))
-            # similarity in salary (closer is better)
-            if target_salary <= 1e-6:
-                sal_term = 0.0
-            else:
-                sal_term = abs(sal - target_salary) / max(1.0, target_salary)
+
+            # lower is better
+            sal_term = 0.0 if target_salary <= 1e-6 else abs(sal - target_salary) / max(1.0, target_salary)
             surplus_bonus = -0.5 if (surplus and pos_g in surplus) else 0.0
-            # low value players are more likely to be shopped
             score = (ovr * 0.08) + (sal_term * 1.2) + surplus_bonus
             rows.append((score, pid_i))
         except Exception:
             continue
-    rows.sort()  # lower score = better outgoing candidate
-    return [pid for _, pid in rows[: int(tuning.outgoing_candidates)]]
+
+    rows.sort()
+    return [pid for _, pid in rows[: int(tuning.outgoing_single_candidates)]]
 
 
-def _best_pick_to_add(buyer_id: str, buyer_ctx: valuation.TeamContext) -> Optional[str]:
-    # "best" here means cheapest for the buyer to give away (lowest value to buyer)
+def _candidate_outgoing_pairs(
+    buyer_id: str,
+    target_salary: float,
+    buyer_ctx: valuation.TeamContext,
+    *,
+    tuning: AITuning,
+) -> List[Tuple[int, int]]:
+    """Outgoing 2-player combinations (2-for-1 template)."""
+
+    singles = _candidate_outgoing_singles(buyer_id, target_salary, buyer_ctx, tuning=tuning)
+    pool = singles[: int(tuning.outgoing_pair_pool)]
+    if len(pool) < 2:
+        return []
+
+    pairs: List[Tuple[float, Tuple[int, int]]] = []
+    for i in range(len(pool)):
+        for j in range(i + 1, len(pool)):
+            a = pool[i]
+            b = pool[j]
+            sal = float(salary_of_player(a)) + float(salary_of_player(b))
+            # closeness to target salary
+            clos = abs(sal - target_salary) / max(1.0, target_salary)
+            pairs.append((clos, (a, b)))
+
+    pairs.sort()
+    return [p for _, p in pairs[: max(1, int(tuning.outgoing_single_candidates))]]
+
+
+# ---------------------------------------------------------------------
+# Picks / sweeteners
+# ---------------------------------------------------------------------
+
+def _best_pick_sweetener(
+    buyer_id: str,
+    seller_id: str,
+    *,
+    team_contexts: Dict[str, valuation.TeamContext],
+    market: valuation.MarketContext,
+    already_used: Sequence[str] = (),
+) -> Optional[str]:
+    """Pick to add that is relatively cheap for buyer but helpful for seller."""
+
     picks = team_picks(buyer_id)
+    picks = [p for p in picks if p.pick_id not in set(map(str, already_used))]
     if not picks:
         return None
+
     scored: List[Tuple[float, str]] = []
     for p in picks:
         try:
-            pid = str(p.get("pick_id"))
-            v = valuation.value_pick_for_team(pid, buyer_id, team_contexts={buyer_id: buyer_ctx})
-            scored.append((float(v), pid))
+            buyer_v = valuation.value_pick_for_team(p.pick_id, buyer_id, team_contexts=team_contexts, market=market)
+            seller_v = valuation.value_pick_for_team(p.pick_id, seller_id, team_contexts=team_contexts, market=market)
+            # maximize seller gain per buyer cost
+            score = float(seller_v - 0.6 * buyer_v)
+            scored.append((score, p.pick_id))
         except Exception:
             continue
+
     if not scored:
         return None
-    scored.sort()  # lowest value to buyer => easiest to give
+
+    scored.sort(reverse=True)
     return scored[0][1]
 
 
+def _best_young_sweetener(
+    buyer_id: str,
+    seller_id: str,
+    *,
+    team_contexts: Dict[str, valuation.TeamContext],
+    market: valuation.MarketContext,
+    exclude_player_ids: Sequence[int] = (),
+) -> Optional[int]:
+    """Young player to add (cheap for buyer, interesting for seller)."""
+
+    df = _roster_df(buyer_id)
+    if df is None or df.empty:
+        return None
+
+    exclude = set(int(x) for x in exclude_player_ids)
+    cand: List[Tuple[float, int]] = []
+    for pid, _row in df.iterrows():
+        try:
+            pid_i = int(pid)
+            if pid_i in exclude:
+                continue
+            pctx = valuation.build_player_context(pid_i)
+            if not pctx:
+                continue
+            if pctx.age > 24 and pctx.potential < 0.82:
+                continue
+
+            buyer_v = valuation.value_player_for_team(pid_i, buyer_id, team_contexts=team_contexts, market=market)
+            seller_v = valuation.value_player_for_team(pid_i, seller_id, team_contexts=team_contexts, market=market)
+            # prefer low buyer value, decent seller value
+            score = float(seller_v - 0.9 * buyer_v)
+            cand.append((score, pid_i))
+        except Exception:
+            continue
+
+    if not cand:
+        return None
+
+    cand.sort(reverse=True)
+    return cand[0][1]
+
+
+# ---------------------------------------------------------------------
+# Evaluation
+# ---------------------------------------------------------------------
+
 def _evaluate_net(
     team_id: str,
     incoming_players: Sequence[int],
@@ -229,80 +421,381 @@
     outgoing_picks: Sequence[str],
     *,
     team_contexts: Dict[str, valuation.TeamContext],
+    market: valuation.MarketContext,
+    partner_id: Optional[str] = None,
 ) -> float:
-    in_val = valuation.package_value_for_team(team_id, player_ids=list(incoming_players), pick_ids=list(incoming_picks), team_contexts=team_contexts)
-    out_val = valuation.package_value_for_team(team_id, player_ids=list(outgoing_players), pick_ids=list(outgoing_picks), team_contexts=team_contexts)
+    in_val = valuation.package_value_for_team(
+        team_id,
+        player_ids=list(incoming_players),
+        pick_ids=list(incoming_picks),
+        team_contexts=team_contexts,
+        market=market,
+        trade_partner_id=partner_id,
+    )
+    out_val = valuation.package_value_for_team(
+        team_id,
+        player_ids=list(outgoing_players),
+        pick_ids=list(outgoing_picks),
+        team_contexts=team_contexts,
+        market=market,
+        trade_partner_id=partner_id,
+    )
     return float(in_val - out_val)
 
 
-def _build_and_test_proposals(
+# ---------------------------------------------------------------------
+# Validation fix helper
+# ---------------------------------------------------------------------
+
+def _try_fix_proposal(
+    proposal: TradeProposal,
+    validation,
+    *,
+    team_contexts: Dict[str, valuation.TeamContext],
+    market: valuation.MarketContext,
+    tuning: AITuning,
+) -> Optional[TradeProposal]:
+    """Attempt a single auto-fix using trade_engine.suggest_fixes."""
+
+    fixes = suggest_fixes(proposal, validation)
+    if not fixes:
+        return None
+
+    # Only one fix attempt per proposal for predictability.
+    fix = fixes[0]
+
+    def pick_filler(team_id: str, amount_needed: float = 0.0, exclude: Sequence[int] = ()) -> Optional[int]:
+        df = _roster_df(team_id)
+        if df is None or df.empty:
+            return None
+        exclude_set = set(int(x) for x in exclude)
+        rows: List[Tuple[float, int]] = []
+        for pid, row in df.iterrows():
+            try:
+                pid_i = int(pid)
+                if pid_i in exclude_set:
+                    continue
+                sal = float(salary_of_player(pid_i))
+                if amount_needed > 0 and sal < amount_needed * 0.85:
+                    continue
+                # low value to its own team
+                own_v = valuation.value_player_for_team(pid_i, team_id, team_contexts=team_contexts, market=market)
+                score = float(own_v) + (0.000001 * sal)
+                rows.append((score, pid_i))
+            except Exception:
+                continue
+        if not rows:
+            return None
+        rows.sort()  # low own value first
+        return rows[0][1]
+
+    # Apply fix
+    if fix.kind in ("add_outgoing_salary", "add_outgoing_player"):
+        side = str(fix.team_side).upper()
+        amt = float(fix.amount or 0.0)
+        if side == "A":
+            filler = pick_filler(proposal.team_a, amt, exclude=proposal.send_a_players)
+            if filler is None:
+                return None
+            prop2 = TradeProposal(
+                team_a=proposal.team_a,
+                team_b=proposal.team_b,
+                send_a_players=list(dict.fromkeys([*proposal.send_a_players, int(filler)])),
+                send_a_picks=list(proposal.send_a_picks),
+                send_b_players=list(proposal.send_b_players),
+                send_b_picks=list(proposal.send_b_picks),
+                date_str=proposal.date_str,
+            )
+        else:
+            filler = pick_filler(proposal.team_b, amt, exclude=proposal.send_b_players)
+            if filler is None:
+                return None
+            prop2 = TradeProposal(
+                team_a=proposal.team_a,
+                team_b=proposal.team_b,
+                send_a_players=list(proposal.send_a_players),
+                send_a_picks=list(proposal.send_a_picks),
+                send_b_players=list(dict.fromkeys([*proposal.send_b_players, int(filler)])),
+                send_b_picks=list(proposal.send_b_picks),
+                date_str=proposal.date_str,
+            )
+
+        v2 = validate_trade(prop2)
+        if v2.ok:
+            return prop2
+        return None
+
+    return None
+
+
+# ---------------------------------------------------------------------
+# Offer generation + negotiation
+# ---------------------------------------------------------------------
+
+def _negotiate_for_acceptance(
+    proposal: TradeProposal,
+    *,
+    team_contexts: Dict[str, valuation.TeamContext],
+    market: valuation.MarketContext,
+    tuning: AITuning,
+    template: str,
+    rng: random.Random,
+) -> Optional[Tuple[TradeProposal, Dict[str, Any]]]:
+    """Try to get both teams over their thresholds (may add sweeteners).
+
+    Returns (final_proposal, evaluation_meta) if accepted.
+    """
+
+    buyer_id = _u(proposal.team_a)
+    seller_id = _u(proposal.team_b)
+    buyer_ctx = team_contexts.get(buyer_id)
+    seller_ctx = team_contexts.get(seller_id)
+    if not buyer_ctx or not seller_ctx:
+        return None
+
+    # First, validate. If invalid, attempt a single fix.
+    v = validate_trade(proposal)
+    if not v.ok:
+        if tuning.max_fix_attempts_per_proposal > 0:
+            fixed = _try_fix_proposal(proposal, v, team_contexts=team_contexts, market=market, tuning=tuning)
+            if fixed is None:
+                return None
+            proposal = fixed
+            v = validate_trade(proposal)
+            if not v.ok:
+                return None
+        else:
+            return None
+
+    # Compute thresholds
+    buyer_thr = threshold_for_team(buyer_ctx, partner_id=seller_id, market=market, direction="buy", tuning=tuning)
+    seller_thr = threshold_for_team(seller_ctx, partner_id=buyer_id, market=market, direction="sell", tuning=tuning)
+
+    def nets(p: TradeProposal) -> Tuple[float, float]:
+        buyer_net = _evaluate_net(
+            buyer_id,
+            incoming_players=p.send_b_players,
+            incoming_picks=p.send_b_picks,
+            outgoing_players=p.send_a_players,
+            outgoing_picks=p.send_a_picks,
+            team_contexts=team_contexts,
+            market=market,
+            partner_id=seller_id,
+        )
+        seller_net = _evaluate_net(
+            seller_id,
+            incoming_players=p.send_a_players,
+            incoming_picks=p.send_a_picks,
+            outgoing_players=p.send_b_players,
+            outgoing_picks=p.send_b_picks,
+            team_contexts=team_contexts,
+            market=market,
+            partner_id=buyer_id,
+        )
+        return float(buyer_net), float(seller_net)
+
+    buyer_net, seller_net = nets(proposal)
+    if buyer_net >= buyer_thr and seller_net >= seller_thr:
+        meta = {
+            "template": template,
+            "buyer_net": buyer_net,
+            "seller_net": seller_net,
+            "buyer_threshold": buyer_thr,
+            "seller_threshold": seller_thr,
+            "validation": {"reasons": list(v.reasons)},
+        }
+        return proposal, meta
+
+    # Negotiation: if seller rejects, buyer can sweeten (picks / young)
+    for _round in range(int(tuning.max_counter_rounds)):
+        if seller_net >= seller_thr:
+            break
+
+        need_delta = float(seller_thr - seller_net)
+
+        # choose sweetener type based on seller profile
+        sp = seller_ctx.gm_profile or {}
+        pick_pref = float(sp.get("pick_hoarder", 0.5) or 0.5) + (0.35 if seller_ctx.status == "rebuild" else 0.0)
+        youth_pref = float(sp.get("youth_bias", 0.5) or 0.5)
+
+        new_proposal: Optional[TradeProposal] = None
+
+        if pick_pref >= youth_pref:
+            if len(proposal.send_a_picks) < int(tuning.max_picks_in_offer):
+                pk = _best_pick_sweetener(
+                    buyer_id,
+                    seller_id,
+                    team_contexts=team_contexts,
+                    market=market,
+                    already_used=proposal.send_a_picks,
+                )
+                if pk:
+                    new_proposal = TradeProposal(
+                        team_a=proposal.team_a,
+                        team_b=proposal.team_b,
+                        send_a_players=list(proposal.send_a_players),
+                        send_a_picks=[*proposal.send_a_picks, str(pk)],
+                        send_b_players=list(proposal.send_b_players),
+                        send_b_picks=list(proposal.send_b_picks),
+                        date_str=proposal.date_str,
+                    )
+
+        if new_proposal is None and tuning.allow_young_sweetener:
+            young = _best_young_sweetener(
+                buyer_id,
+                seller_id,
+                team_contexts=team_contexts,
+                market=market,
+                exclude_player_ids=proposal.send_a_players,
+            )
+            if young is not None:
+                new_proposal = TradeProposal(
+                    team_a=proposal.team_a,
+                    team_b=proposal.team_b,
+                    send_a_players=[*proposal.send_a_players, int(young)],
+                    send_a_picks=list(proposal.send_a_picks),
+                    send_b_players=list(proposal.send_b_players),
+                    send_b_picks=list(proposal.send_b_picks),
+                    date_str=proposal.date_str,
+                )
+
+        if new_proposal is None:
+            break
+
+        v2 = validate_trade(new_proposal)
+        if not v2.ok:
+            fixed = _try_fix_proposal(new_proposal, v2, team_contexts=team_contexts, market=market, tuning=tuning)
+            if fixed is None:
+                break
+            new_proposal = fixed
+            v2 = validate_trade(new_proposal)
+            if not v2.ok:
+                break
+
+        buyer_net2, seller_net2 = nets(new_proposal)
+
+        # Buyer can't destroy itself to get deal done.
+        if buyer_net2 < buyer_thr:
+            break
+
+        proposal = new_proposal
+        buyer_net, seller_net = buyer_net2, seller_net2
+
+        if buyer_net >= buyer_thr and seller_net >= seller_thr:
+            meta = {
+                "template": template,
+                "buyer_net": buyer_net,
+                "seller_net": seller_net,
+                "buyer_threshold": buyer_thr,
+                "seller_threshold": seller_thr,
+                "negotiation_rounds": _round + 1,
+                "need_delta_initial": need_delta,
+                "validation": {"reasons": list(v2.reasons)},
+            }
+            return proposal, meta
+
+    return None
+
+
+def _build_proposals_for_target(
     buyer_id: str,
     seller_id: str,
     target_id: int,
     *,
     team_contexts: Dict[str, valuation.TeamContext],
+    market: valuation.MarketContext,
     tuning: AITuning,
-) -> Optional[TradeProposal]:
+    rng: random.Random,
+) -> List[Tuple[TradeProposal, str]]:
+    """Generate candidate proposals for a specific target."""
+
     buyer_ctx = team_contexts.get(_u(buyer_id))
-    seller_ctx = team_contexts.get(_u(seller_id))
-    if not buyer_ctx or not seller_ctx:
-        return None
+    if not buyer_ctx:
+        return []
 
     target_salary = float(salary_of_player(int(target_id)))
-    outgoing_candidates = _candidate_outgoing_players(buyer_id, target_salary, buyer_ctx, tuning=tuning)
-    if not outgoing_candidates:
-        return None
 
-    # Start with 1-for-1, then optionally add picks to satisfy seller
-    for out_pid in outgoing_candidates:
-        proposal = TradeProposal(
-            team_a=_u(buyer_id),
-            team_b=_u(seller_id),
-            send_a_players=[int(out_pid)],
-            send_a_picks=[],
-            send_b_players=[int(target_id)],
-            send_b_picks=[],
-            date_str=None,
-        )
+    singles = _candidate_outgoing_singles(buyer_id, target_salary, buyer_ctx, tuning=tuning)
+    pairs = _candidate_outgoing_pairs(buyer_id, target_salary, buyer_ctx, tuning=tuning)
 
-        # Validate rules first (cheap filter)
-        v = validate_trade(proposal)
-        if not v.ok:
-            # Salary mismatch can sometimes be solved by using another outgoing candidate; keep trying.
-            continue
+    proposals: List[Tuple[TradeProposal, str]] = []
 
-        buyer_net = _evaluate_net(_u(buyer_id), [target_id], [], [out_pid], [], team_contexts=team_contexts)
-        seller_net = _evaluate_net(_u(seller_id), [out_pid], [], [target_id], [], team_contexts=team_contexts)
+    # T1: 1-for-1
+    for out_pid in singles:
+        proposals.append((
+            TradeProposal(
+                team_a=_u(buyer_id),
+                team_b=_u(seller_id),
+                send_a_players=[int(out_pid)],
+                send_a_picks=[],
+                send_b_players=[int(target_id)],
+                send_b_picks=[],
+                date_str=None,
+            ),
+            "1for1",
+        ))
+
+    # T2: 2-for-1 (buyer sends 2)
+    for (p1, p2) in pairs:
+        proposals.append((
+            TradeProposal(
+                team_a=_u(buyer_id),
+                team_b=_u(seller_id),
+                send_a_players=[int(p1), int(p2)],
+                send_a_picks=[],
+                send_b_players=[int(target_id)],
+                send_b_picks=[],
+                date_str=None,
+            ),
+            "2for1",
+        ))
+
+    # Shuffle a bit so AI is less repetitive
+    rng.shuffle(proposals)
+    return proposals[: int(tuning.proposals_per_pair_cap)]
 
-        if buyer_net >= _threshold_for(buyer_ctx.status, tuning) and seller_net >= _threshold_for(seller_ctx.status, tuning):
-            return proposal
 
-        # If seller isn't happy, add up to N picks (one at a time), re-evaluate.
-        if seller_net < _threshold_for(seller_ctx.status, tuning):
-            added: List[str] = []
-            for _ in range(int(tuning.max_picks_in_offer)):
-                pick_id = _best_pick_to_add(buyer_id, buyer_ctx)
-                if not pick_id or pick_id in added:
-                    break
-                added.append(pick_id)
-                proposal2 = TradeProposal(
-                    team_a=_u(buyer_id),
-                    team_b=_u(seller_id),
-                    send_a_players=[int(out_pid)],
-                    send_a_picks=list(added),
-                    send_b_players=[int(target_id)],
-                    send_b_picks=[],
-                    date_str=None,
-                )
-                v2 = validate_trade(proposal2)
-                if not v2.ok:
-                    continue
+def _attempt_trade_between(
+    buyer_id: str,
+    seller_id: str,
+    *,
+    team_contexts: Dict[str, valuation.TeamContext],
+    market: valuation.MarketContext,
+    tuning: AITuning,
+    rng: random.Random,
+) -> Optional[Tuple[TradeProposal, Dict[str, Any]]]:
+    """Try to create and accept one trade between buyer and seller."""
 
-                buyer_net2 = _evaluate_net(_u(buyer_id), [target_id], [], [out_pid], list(added), team_contexts=team_contexts)
-                seller_net2 = _evaluate_net(_u(seller_id), [out_pid], list(added), [target_id], [], team_contexts=team_contexts)
+    buyer_ctx = team_contexts.get(_u(buyer_id))
+    seller_ctx = team_contexts.get(_u(seller_id))
+    if not buyer_ctx or not seller_ctx:
+        return None
+
+    targets = _candidate_targets(seller_id, buyer_ctx, tuning=tuning)
+    rng.shuffle(targets)
 
-                if buyer_net2 >= _threshold_for(buyer_ctx.status, tuning) and seller_net2 >= _threshold_for(seller_ctx.status, tuning):
-                    return proposal2
+    for target_id in targets:
+        proposals = _build_proposals_for_target(
+            buyer_id,
+            seller_id,
+            target_id,
+            team_contexts=team_contexts,
+            market=market,
+            tuning=tuning,
+            rng=rng,
+        )
+        for prop, template in proposals:
+            accepted = _negotiate_for_acceptance(
+                prop,
+                team_contexts=team_contexts,
+                market=market,
+                tuning=tuning,
+                template=template,
+                rng=rng,
+            )
+            if accepted is None:
+                continue
+            return accepted
 
     return None
 
@@ -313,6 +806,7 @@
 
 def run_ai_gm_tick(today: date, *, user_team_id: Optional[str] = None, tuning: Optional[AITuning] = None) -> None:
     """Run one AI GM tick (may execute 0..N trades)."""
+
     tuning = tuning or AITuning()
 
     if _past_deadline(today):
@@ -323,14 +817,18 @@
     ensure_contracts_initialized()
     ensure_draft_picks_initialized()
 
+    # Ensure GM profiles / relationships exist
+    valuation.ensure_gm_profiles_initialized()
+    valuation.ensure_relationships_initialized()
+
     team_contexts = valuation.build_team_contexts()
+    market = _market_context(today)
 
     teams = _teams_for_ai(user_team_id)
     if len(teams) < 2:
         _mark_tick(today)
         return
 
-    # Determine buyer/seller pools
     buyers: List[str] = []
     sellers: List[str] = []
     neutrals: List[str] = []
@@ -347,14 +845,12 @@
         else:
             neutrals.append(tid)
 
-    # If pools are empty, allow neutral trades very rarely
     if not buyers:
         buyers = neutrals[:]
     if not sellers:
         sellers = neutrals[:]
 
     rng = random.Random()
-    # If you want reproducibility, you can store a seed in league state
     league = _ensure_league_state()
     seed = league.get("rng_seed")
     if seed is not None:
@@ -376,59 +872,44 @@
         if _u(buyer_id) in involved:
             continue
 
-        buyer_ctx = team_contexts.get(_u(buyer_id))
-        if not buyer_ctx:
-            continue
-
-        # Pick a few sellers to probe
         probe = [s for s in sellers if _u(s) not in involved and _u(s) != _u(buyer_id)]
         rng.shuffle(probe)
         probe = probe[: int(tuning.sellers_per_buyer)]
+
         for seller_id in probe:
             if trades_done >= max_trades:
                 break
             if _u(seller_id) in involved:
                 continue
-            seller_ctx = team_contexts.get(_u(seller_id))
-            if not seller_ctx:
-                continue
-
-            # Generate a few targets from this seller
-            targets = _candidate_targets(seller_id, buyer_ctx, tuning=tuning)
-            rng.shuffle(targets)
-            for target_id in targets:
-                if trades_done >= max_trades:
-                    break
 
-                proposal = _build_and_test_proposals(
-                    buyer_id,
-                    seller_id,
-                    target_id,
-                    team_contexts=team_contexts,
-                    tuning=tuning,
-                )
-                if proposal is None:
-                    continue
+            accepted = _attempt_trade_between(
+                buyer_id,
+                seller_id,
+                team_contexts=team_contexts,
+                market=market,
+                tuning=tuning,
+                rng=rng,
+            )
+            if accepted is None:
+                continue
 
-                # Apply
-                try:
-                    proposal = TradeProposal(**{**proposal.__dict__, "date_str": today.isoformat()})
-                    apply_trade(proposal, record_transaction=True, record_weekly_news=True)
-                    trades_done += 1
-                    involved.add(_u(buyer_id))
-                    involved.add(_u(seller_id))
-                    break
-                except Exception:
-                    # If apply fails unexpectedly, ignore and continue.
-                    continue
-            if _u(buyer_id) in involved:
+            proposal, meta = accepted
+            try:
+                proposal = TradeProposal(**{**proposal.__dict__, "date_str": today.isoformat()})
+                apply_trade(proposal, record_transaction=True, record_weekly_news=True, evaluation=meta)
+                trades_done += 1
+                involved.add(_u(buyer_id))
+                involved.add(_u(seller_id))
                 break
+            except Exception:
+                continue
 
     _mark_tick(today)
 
 
 def _run_ai_gm_tick_if_needed(current_date: date, user_team_id: Optional[str] = None) -> None:
-    """Compatibility shim with the old trades_ai module name."""
+    """Compatibility shim (older league_sim used trades_ai)."""
+
     tuning = AITuning()
     if not _should_tick(current_date, tuning=tuning):
         return
