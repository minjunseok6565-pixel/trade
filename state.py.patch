diff --git a/state.py b/state.py
index 1c7a3f2..0b6b8a9 100644
--- a/state.py
+++ b/state.py
@@ -1,16 +1,17 @@
 from __future__ import annotations
 
+from collections.abc import Mapping, Sequence
 from copy import deepcopy
 from datetime import date
 from threading import RLock
-from typing import Any, Callable, Optional
+from typing import Any, Callable, Optional, TypeVar
 
 from config import ALL_TEAM_IDS, INITIAL_SEASON_YEAR, SEASON_START_DAY, SEASON_START_MONTH
 from schema import season_id_from_year as _season_id_from_year
 from state_modules.state_constants import (
     DEFAULT_TRADE_RULES,
@@ -23,8 +24,7 @@ from state_modules.state_constants import (
     _DEFAULT_TRADE_MEMORY,
     _META_PLAYER_KEYS,
 )
-from state_modules.state_store import _get_state, reset_state_for_dev as _reset_state_for_dev
-from state_schema import validate_game_state
+from state_modules.state_store import read_state, reset_state_for_dev as _reset_state_for_dev, snapshot_state, transaction
 
 __all__ = [
     "DEFAULT_TRADE_RULES",
@@ -78,9 +78,55 @@ __all__ = [
     "reset_state_for_dev",
 ]
 
+T = TypeVar("T")
 
-def _s() -> dict:
-    return _get_state()
+def _mutate_state(reason: str, fn: Callable[[dict], T]) -> T:
+    """All state mutations must go through this helper."""
+    with transaction(reason) as state:
+        return fn(state)
+
+
+def _read_state(fn: Callable[[Mapping[str, Any]], T]) -> T:
+    """Read-only access helper (no mutation, no global dict exposure)."""
+    with read_state() as view:
+        return fn(view)
+
+
+def _to_plain(value: Any) -> Any:
+    """Convert read-only views (and nested structures) into plain dict/list recursively."""
+    if isinstance(value, Mapping):
+        return {str(k): _to_plain(v) for k, v in value.items()}
+    if isinstance(value, Sequence) and not isinstance(value, (str, bytes, bytearray)):
+        return [_to_plain(v) for v in value]
+    return value
 
 
 # NOTE: Single-process safety. Serialize all negotiation session mutations
 # to prevent lost updates (read-modify-write races).
 _NEGOTIATIONS_LOCK = RLock()
@@ -103,25 +149,27 @@ def _season_id_for_year(season_year: int) -> str:
     return str(_season_id_from_year(int(season_year)))
 
 
-def _ensure_db_path_in_state() -> str:
+def _ensure_db_path_in_league(league: dict) -> str:
     """contracts.offseason이 요구하는 league.db_path를 항상 채워 넣는다."""
-    league = _s().get("league")
     if not isinstance(league, dict):
         raise ValueError("GameState invalid: league must be dict")
     db_path = league.get("db_path")
     if db_path:
         return str(db_path)
     # 기존 코드베이스의 기본 정책과 동일하게 league.db를 기본값으로 둔다.
     league["db_path"] = "league.db"
     return "league.db"
@@ -136,18 +184,18 @@ def _clear_master_schedule(league: dict) -> None:
     ms["by_team"] = {}
     ms["by_date"] = {}
     ms["by_id"] = {}
 
-def _ensure_draft_picks_seeded_for_season_year(season_year: int) -> None:
+def _ensure_draft_picks_seeded_for_season_year(state: dict, season_year: int) -> None:
     """스케줄 생성/시즌 시작을 위해 필요한 draft_picks seed를 보장한다."""
-    league = _s()["league"]
-    _ensure_db_path_in_state()
+    league = state["league"]
+    _ensure_db_path_in_league(league)
 
     trade_rules = league.get("trade_rules") or {}
     try:
         max_pick_years_ahead = int(trade_rules.get("max_pick_years_ahead") or 7)
@@ -166,7 +214,7 @@ def _ensure_draft_picks_seeded_for_season_year(season_year: int) -> None:
 
     from league_repo import LeagueRepo
 
-    db_path = str(_s()["league"]["db_path"])
+    db_path = str(league["db_path"])
     draft_year = int(season_year) + 1
     with LeagueRepo(db_path) as repo:
         repo.init_db()
@@ -174,10 +222,13 @@ def _ensure_draft_picks_seeded_for_season_year(season_year: int) -> None:
 
 
 def ensure_schedule_for_active_season(*, force: bool = False) -> None:
     """현재 active_season_id에 맞는 master_schedule을 보장한다(시즌 전환은 하지 않음)."""
-    state = _s()
-    league = state.get("league")
-    if not isinstance(league, dict):
-        raise ValueError("GameState invalid: league must be dict")
+    def _impl(state: dict) -> None:
+        league = state.get("league")
+        if not isinstance(league, dict):
+            raise ValueError("GameState invalid: league must be dict")
 
-    active = state.get("active_season_id")
-    if active is None:
-        raise ValueError(
-            "active_season_id is None. "
-            "Call state.start_new_season(...) or state.set_active_season_id(...) first."
-        )
-    if not isinstance(active, str):
-        raise ValueError("GameState invalid: active_season_id must be str")
+        active = state.get("active_season_id")
+        if active is None:
+            raise ValueError(
+                "active_season_id is None. "
+                "Call state.start_new_season(...) or state.set_active_season_id(...) first."
+            )
+        if not isinstance(active, str):
+            raise ValueError("GameState invalid: active_season_id must be str")
 
-    active_year = _season_year_from_season_id(active)
+        active_year = _season_year_from_season_id(active)
 
-    # SSOT 동기화(미리 채움): league.season_year/draft_year는 active와 일치해야 한다.
-    league_year = league.get("season_year")
-    if league_year is None:
-        league["season_year"] = int(active_year)
-        league_year = int(active_year)
-    try:
-        league_year_i = int(league_year)
-    except Exception as exc:
-        raise ValueError("GameState invalid: league.season_year must be int") from exc
-    if league_year_i != int(active_year):
-        raise ValueError(
-            f"Season mismatch: league.season_year={league_year_i} != active_season_id={active}. "
-            "Use state.start_new_season(...) to transition seasons."
-        )
+        # SSOT 동기화(미리 채움): league.season_year/draft_year는 active와 일치해야 한다.
+        league_year = league.get("season_year")
+        if league_year is None:
+            league["season_year"] = int(active_year)
+            league_year = int(active_year)
+        try:
+            league_year_i = int(league_year)
+        except Exception as exc:
+            raise ValueError("GameState invalid: league.season_year must be int") from exc
+        if league_year_i != int(active_year):
+            raise ValueError(
+                f"Season mismatch: league.season_year={league_year_i} != active_season_id={active}. "
+                "Use state.start_new_season(...) to transition seasons."
+            )
 
-    draft_year = league.get("draft_year")
-    if draft_year is None:
-        league["draft_year"] = int(league_year_i) + 1
-    else:
-        try:
-            draft_year_i = int(draft_year)
-        except Exception as exc:
-            raise ValueError("GameState invalid: league.draft_year must be int") from exc
-        if draft_year_i != int(league_year_i) + 1:
-            raise ValueError("GameState invalid: league.draft_year must equal league.season_year + 1")
+        draft_year = league.get("draft_year")
+        if draft_year is None:
+            league["draft_year"] = int(league_year_i) + 1
+        else:
+            try:
+                draft_year_i = int(draft_year)
+            except Exception as exc:
+                raise ValueError("GameState invalid: league.draft_year must be int") from exc
+            if draft_year_i != int(league_year_i) + 1:
+                raise ValueError("GameState invalid: league.draft_year must equal league.season_year + 1")
 
-    ms = league.get("master_schedule")
-    if not isinstance(ms, dict):
-        raise ValueError("GameState invalid: league.master_schedule must be dict")
+        ms = league.get("master_schedule")
+        if not isinstance(ms, dict):
+            raise ValueError("GameState invalid: league.master_schedule must be dict")
 
-    games = ms.get("games") or []
-    rebuild = False
-    if force:
-        rebuild = True
-    elif not isinstance(games, list) or len(games) == 0:
-        rebuild = True
-    else:
-        g0 = games[0] if games else None
-        if isinstance(g0, dict):
-            sid = g0.get("season_id")
-            if sid is not None and str(sid) != str(active):
-                rebuild = True
+        games = ms.get("games") or []
+        rebuild = False
+        if force:
+            rebuild = True
+        elif not isinstance(games, list) or len(games) == 0:
+            rebuild = True
+        else:
+            g0 = games[0] if games else None
+            if isinstance(g0, dict):
+                sid = g0.get("season_id")
+                if sid is not None and str(sid) != str(active):
+                    rebuild = True
 
-    if rebuild:
-        # schedule 생성에 필요한 부수효과는 facade가 수행한다.
-        from state_modules.state_cap import _apply_cap_model_for_season
-        from state_modules import state_bootstrap, state_schedule
+        if rebuild:
+            # schedule 생성에 필요한 부수효과는 facade가 수행한다.
+            from state_modules.state_cap import _apply_cap_model_for_season
+            from state_modules import state_bootstrap, state_schedule
 
-        _ensure_db_path_in_state()
-        _apply_cap_model_for_season(league, int(active_year))
-        _ensure_draft_picks_seeded_for_season_year(int(active_year))
+            _ensure_db_path_in_league(league)
+            _apply_cap_model_for_season(league, int(active_year))
+            _ensure_draft_picks_seeded_for_season_year(state, int(active_year))
 
-        season_start = date(int(active_year), SEASON_START_MONTH, SEASON_START_DAY)
-        built = state_schedule.build_master_schedule(season_year=int(active_year), season_start=season_start, rng_seed=None)
+            season_start = date(int(active_year), SEASON_START_MONTH, SEASON_START_DAY)
+            built = state_schedule.build_master_schedule(
+                season_year=int(active_year),
+                season_start=season_start,
+                rng_seed=None,
+            )
 
-        ms["games"] = built["games"]
-        ms["by_team"] = built["by_team"]
-        ms["by_date"] = built["by_date"]
-        ms["by_id"] = built["by_id"]
+            ms["games"] = built["games"]
+            ms["by_team"] = built["by_team"]
+            ms["by_date"] = built["by_date"]
+            ms["by_id"] = built["by_id"]
 
-        league["season_start"] = season_start.isoformat()
-        trade_deadline = date(int(active_year) + 1, 2, 5)
-        league["trade_rules"]["trade_deadline"] = trade_deadline.isoformat()
-        league["current_date"] = None
-        league["last_gm_tick_date"] = None
+            league["season_start"] = season_start.isoformat()
+            trade_deadline = date(int(active_year) + 1, 2, 5)
+            league["trade_rules"]["trade_deadline"] = trade_deadline.isoformat()
+            league["current_date"] = None
+            league["last_gm_tick_date"] = None
 
-        # schedule 생성 직후의 계약 bootstrap 체크포인트(once per season)
-        state_bootstrap.ensure_contracts_bootstrapped_after_schedule_creation_once(state)
+            # schedule 생성 직후의 계약 bootstrap 체크포인트(once per season)
+            state_bootstrap.ensure_contracts_bootstrapped_after_schedule_creation_once(state)
 
-    # 인덱스 보정
-    from state_modules import state_schedule
-    state_schedule.ensure_master_schedule_indices(ms)
+        # 인덱스 보정
+        from state_modules import state_schedule
+
+        state_schedule.ensure_master_schedule_indices(ms)
 
-    validate_game_state(state)
+    _mutate_state("ensure_schedule_for_active_season", _impl)
 
 
 def start_new_season(
@@ -186,62 +237,68 @@ def start_new_season(
     rebuild_schedule: bool = True,
     run_offseason: bool = True,
 ) -> dict:
     """'시즌 전환'의 유일한 공식 API."""
-    state = _s()
-    league = state.get("league")
-    if not isinstance(league, dict):
-        raise ValueError("GameState invalid: league must be dict")
+    def _impl(state: dict) -> dict:
+        league = state.get("league")
+        if not isinstance(league, dict):
+            raise ValueError("GameState invalid: league must be dict")
 
-    target_year = int(season_year)
-    if target_year <= 0:
-        raise ValueError("season_year must be positive int")
+        target_year = int(season_year)
+        if target_year <= 0:
+            raise ValueError("season_year must be positive int")
 
-    _ensure_db_path_in_state()
+        _ensure_db_path_in_league(league)
 
-    prev_active = state.get("active_season_id")
-    prev_year = None
-    if prev_active is not None:
-        prev_year = _season_year_from_season_id(str(prev_active))
+        prev_active = state.get("active_season_id")
+        prev_year = None
+        if prev_active is not None:
+            prev_year = _season_year_from_season_id(str(prev_active))
 
-    offseason_result = None
-    if run_offseason and prev_year is not None and int(prev_year) != int(target_year):
-        from contracts.offseason import process_offseason
+        offseason_result = None
+        if run_offseason and prev_year is not None and int(prev_year) != int(target_year):
+            from contracts.offseason import process_offseason
 
-        offseason_result = process_offseason(
-            state,
-            from_season_year=int(prev_year),
-            to_season_year=int(target_year),
-            decision_policy=None,
-            draft_pick_order_by_pick_id=None,
-        )
+            offseason_result = process_offseason(
+                state,
+                from_season_year=int(prev_year),
+                to_season_year=int(target_year),
+                decision_policy=None,
+                draft_pick_order_by_pick_id=None,
+            )
 
-    next_sid = _season_id_for_year(int(target_year))
-    set_active_season_id(next_sid)
+        next_sid = _season_id_for_year(int(target_year))
+        set_active_season_id(next_sid)
 
-    # SSOT 동기화
-    league = state["league"]
-    league["season_year"] = int(target_year)
-    league["draft_year"] = int(target_year) + 1
+        # SSOT 동기화는 set_active_season_id가 수행한다.
 
-    if rebuild_schedule:
-        ensure_schedule_for_active_season(force=True)
-    else:
-        _clear_master_schedule(league)
-        validate_game_state(state)
+        if rebuild_schedule:
+            ensure_schedule_for_active_season(force=True)
+        else:
+            _clear_master_schedule(league)
 
-    return {
-        "ok": True,
-        "from_season_year": prev_year,
-        "to_season_year": int(target_year),
-        "offseason": offseason_result,
-        "active_season_id": state.get("active_season_id"),
-    }
+        return {
+            "ok": True,
+            "from_season_year": prev_year,
+            "to_season_year": int(target_year),
+            "offseason": offseason_result,
+            "active_season_id": state.get("active_season_id"),
+        }
+
+    return _mutate_state("start_new_season", _impl)
 
-def _require_active_season_id_matches(season_id: str) -> str:
+
+def _require_active_season_id_matches(state: dict, season_id: str) -> str:
     """ingest 등 공개 동작에서 'active season' 불일치를 fail-fast로 차단한다."""
-    active = _s().get("active_season_id")
+    active = state.get("active_season_id")
     if active is None:
         raise ValueError(
             "GameState invalid: active_season_id is None. "
             "Call state.set_active_season_id(<season_id>) before ingest."
@@ -258,45 +315,50 @@ def _require_active_season_id_matches(season_id: str) -> str:
     return str(active)
 
 
 def startup_init_state() -> None:
-    validate_game_state(_s())
-    from state_modules import state_bootstrap
-    from state_modules import state_migrations
+    def _impl(state: dict) -> None:
+        from state_modules import state_bootstrap
+        from state_modules import state_migrations
 
-    state_bootstrap.ensure_db_initialized_and_seeded(_s())
+        state_bootstrap.ensure_db_initialized_and_seeded(state)
 
-    # SSOT 초기화: active_season_id / league.season_year가 비어있으면 INITIAL 시즌을 명시적으로 시작한다.
-    if _s().get("active_season_id") is None and _s().get("league", {}).get("season_year") is None:
-        start_new_season(INITIAL_SEASON_YEAR, rebuild_schedule=True, run_offseason=False)
-    else:
-        # 불완전 저장/레거시 상태 방어: 한쪽만 존재하면 다른 쪽을 최소 보정(아카이브/리셋 없음)
-        active = _s().get("active_season_id")
-        league_year = _s().get("league", {}).get("season_year")
-        if active is None and league_year is not None:
-            sid = _season_id_for_year(int(league_year))
-            _s()["active_season_id"] = sid
-            _s()["league"]["draft_year"] = int(league_year) + 1
-        elif active is not None and league_year is None:
-            ay = _season_year_from_season_id(str(active))
-            _s()["league"]["season_year"] = int(ay)
-            _s()["league"]["draft_year"] = int(ay) + 1
+        # SSOT 초기화: active_season_id / league.season_year가 비어있으면 INITIAL 시즌을 명시적으로 시작한다.
+        league = state.get("league") or {}
+        if state.get("active_season_id") is None and league.get("season_year") is None:
+            start_new_season(INITIAL_SEASON_YEAR, rebuild_schedule=True, run_offseason=False)
+        else:
+            # 불완전 저장/레거시 상태 방어: 한쪽만 존재하면 다른 쪽을 최소 보정(아카이브/리셋 없음)
+            active = state.get("active_season_id")
+            league_year = (state.get("league") or {}).get("season_year")
+            if active is None and league_year is not None:
+                sid = _season_id_for_year(int(league_year))
+                state["active_season_id"] = sid
+                state["league"]["draft_year"] = int(league_year) + 1
+            elif active is not None and league_year is None:
+                ay = _season_year_from_season_id(str(active))
+                state["league"]["season_year"] = int(ay)
+                state["league"]["draft_year"] = int(ay) + 1
 
-        ensure_schedule_for_active_season(force=False)
+            ensure_schedule_for_active_season(force=False)
 
-    state_bootstrap.ensure_cap_model_populated_if_needed(_s())
-    state_bootstrap.validate_repo_integrity_once_startup(_s())
-    state_migrations.ensure_ingest_turn_backfilled_once_startup(_s())
-    validate_game_state(_s())
+        state_bootstrap.ensure_cap_model_populated_if_needed(state)
+        state_bootstrap.validate_repo_integrity_once_startup(state)
+        state_migrations.ensure_ingest_turn_backfilled_once_startup(state)
+
+    _mutate_state("startup_init_state", _impl)
 
 
 def validate_state() -> None:
-    validate_game_state(_s())
+    # Outermost transaction commit runs validate_game_state().
+    with transaction("validate_state"):
+        return None
 
 
 def export_workflow_state(
@@ -318,43 +380,53 @@ def export_workflow_state(
         "playoff_news": {"series_game_counts": {}, "items": []},
         "_meta": {
             "scores": {"built_from_turn": -1, "season_id": None},
             "schedule": {"built_from_turn_by_team": {}, "season_id": None},
         },
     }
 
-    # SSOT 동기화: league.season_year/draft_year를 active와 맞춘다.
-    next_year = _season_year_from_season_id(str(next_season_id))
-    _s()["league"]["season_year"] = int(next_year)
-    _s()["league"]["draft_year"] = int(next_year) + 1
+        # SSOT 동기화: league.season_year/draft_year를 active와 맞춘다.
+        next_year = _season_year_from_season_id(str(next_season_id))
+        state["league"]["season_year"] = int(next_year)
+        state["league"]["draft_year"] = int(next_year) + 1
 
-    # 기존 master_schedule은 다른 시즌 것일 수 있으므로 반드시 비워서 stale 제거
-    _clear_master_schedule(_s()["league"])
+        # 기존 master_schedule은 다른 시즌 것일 수 있으므로 반드시 비워서 stale 제거
+        _clear_master_schedule(state["league"])
 
-    validate_game_state(_s())
+    _mutate_state("set_active_season_id", _impl)
 
 
 def ingest_game_result(
     game_result: dict,
     game_date: str | None = None,
 ) -> dict:
     from state_modules import state_results
     from state_modules import state_schedule
 
     state_results.validate_v2_game_result(game_result)
-    _s()["turn"] = int(_s().get("turn", 0) or 0) + 1
-    game = game_result["game"]
-    season_id = str(game["season_id"])
-    _require_active_season_id_matches(season_id)
-    phase = str(game["phase"])
-    if phase == "regular":
-        container = _s()
-    elif phase in {"preseason", "play_in", "playoffs"}:
-        container = _s()["phase_results"][phase]
-    else:
-        raise ValueError("invalid phase")
-
-    home_id = str(game["home_team_id"])
-    away_id = str(game["away_team_id"])
-    final = game_result["final"]
-    game_date_str = str(game_date) if game_date else str(game["date"])
-    game_id = str(game["game_id"])
-    home_score = int(final[home_id])
-    away_score = int(final[away_id])
-    game_obj = {
-        "game_id": game_id,
-        "date": game_date_str,
-        "home_team_id": home_id,
-        "away_team_id": away_id,
-        "home_score": home_score,
-        "away_score": away_score,
-        "status": "final",
-        "is_overtime": int(game.get("overtime_periods", 0) or 0) > 0,
-        "phase": phase,
-        "season_id": season_id,
-        "schema_version": "2.0",
-        "ingest_turn": int(_s()["turn"]),
-    }
-
-    container["games"].append(game_obj)
-    container["game_results"][game_id] = game_result
-
-    teams = game_result["teams"]
-    season_player_stats = container["player_stats"]
-    season_team_stats = container["team_stats"]
-    for tid in (home_id, away_id):
-        team_game = teams[tid]
-        state_results._accumulate_team_game_result(tid, team_game, season_team_stats)
-        rows = team_game.get("players") or []
-        if not isinstance(rows, list):
-            raise ValueError(f"GameResultV2 invalid: teams.{tid}.players must be list")
-        state_results._accumulate_player_rows(rows, season_player_stats)
-
-    ms = _s()["league"]["master_schedule"]
-    state_schedule.mark_master_schedule_game_final(
-        ms,
-        game_id=game_id,
-        game_date_str=game_date_str,
-        home_id=home_id,
-        away_id=away_id,
-        home_score=home_score,
-        away_score=away_score,
-    )
-
-    _s()["cached_views"]["_meta"]["scores"]["built_from_turn"] = -1
-    _s()["cached_views"]["_meta"]["schedule"]["built_from_turn_by_team"] = {}
-    _s()["cached_views"]["stats"]["leaders"] = None
-    validate_game_state(_s())
-    return game_obj
+
+    def _impl(state: dict) -> dict:
+        game = game_result["game"]
+        season_id = str(game["season_id"])
+        _require_active_season_id_matches(state, season_id)
+
+        phase = str(game["phase"])
+        if phase == "regular":
+            container = state
+        elif phase in {"preseason", "play_in", "playoffs"}:
+            container = state["phase_results"][phase]
+        else:
+            raise ValueError("invalid phase")
+
+        home_id = str(game["home_team_id"])
+        away_id = str(game["away_team_id"])
+        final = game_result["final"]
+        game_date_str = str(game_date) if game_date else str(game["date"])
+        game_id = str(game["game_id"])
+        home_score = int(final[home_id])
+        away_score = int(final[away_id])
+
+        # Compute next turn early, but only apply after fail-fast checks above.
+        next_turn = int(state.get("turn", 0) or 0) + 1
+        state["turn"] = next_turn
+
+        game_obj = {
+            "game_id": game_id,
+            "date": game_date_str,
+            "home_team_id": home_id,
+            "away_team_id": away_id,
+            "home_score": home_score,
+            "away_score": away_score,
+            "status": "final",
+            "is_overtime": int(game.get("overtime_periods", 0) or 0) > 0,
+            "phase": phase,
+            "season_id": season_id,
+            "schema_version": "2.0",
+            "ingest_turn": int(next_turn),
+        }
+
+        container["games"].append(game_obj)
+        container["game_results"][game_id] = game_result
+
+        teams = game_result["teams"]
+        season_player_stats = container["player_stats"]
+        season_team_stats = container["team_stats"]
+        for tid in (home_id, away_id):
+            team_game = teams[tid]
+            state_results._accumulate_team_game_result(tid, team_game, season_team_stats)
+            rows = team_game.get("players") or []
+            if not isinstance(rows, list):
+                raise ValueError(f"GameResultV2 invalid: teams.{tid}.players must be list")
+            state_results._accumulate_player_rows(rows, season_player_stats)
+
+        ms = state["league"]["master_schedule"]
+        state_schedule.mark_master_schedule_game_final(
+            ms,
+            game_id=game_id,
+            game_date_str=game_date_str,
+            home_id=home_id,
+            away_id=away_id,
+            home_score=home_score,
+            away_score=away_score,
+        )
+
+        state["cached_views"]["_meta"]["scores"]["built_from_turn"] = -1
+        state["cached_views"]["_meta"]["schedule"]["built_from_turn_by_team"] = {}
+        state["cached_views"]["stats"]["leaders"] = None
+        return game_obj
+
+    return _mutate_state("ingest_game_result", _impl)
@@ -443,131 +515,194 @@ def validate_master_schedule_entry(entry: dict, *, path: str = "master_schedule.entry") -> None:
     return state_schedule.validate_master_schedule_entry(entry, path=path)
 
 
 def get_postseason_snapshot() -> dict:
-    return deepcopy(_s()["postseason"])
+    return _read_state(lambda v: _to_plain(v["postseason"]))
 
 
 def postseason_set_field(field) -> None:
-    _s()["postseason"]["field"] = deepcopy(field)
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state["postseason"]["field"] = deepcopy(field)
+
+    _mutate_state("postseason_set_field", _impl)
 
 
 def postseason_set_play_in(state) -> None:
-    _s()["postseason"]["play_in"] = deepcopy(state)
-    validate_game_state(_s())
+    def _impl(gs: dict) -> None:
+        gs["postseason"]["play_in"] = deepcopy(state)
+
+    _mutate_state("postseason_set_play_in", _impl)
 
 
 def postseason_set_playoffs(state) -> None:
-    _s()["postseason"]["playoffs"] = deepcopy(state)
-    validate_game_state(_s())
+    def _impl(gs: dict) -> None:
+        gs["postseason"]["playoffs"] = deepcopy(state)
+
+    _mutate_state("postseason_set_playoffs", _impl)
 
 
 def postseason_set_champion(team_id) -> None:
-    _s()["postseason"]["champion"] = team_id
-    validate_game_state(_s())
+    def _impl(gs: dict) -> None:
+        gs["postseason"]["champion"] = team_id
+
+    _mutate_state("postseason_set_champion", _impl)
 
 
 def postseason_set_my_team_id(team_id) -> None:
-    _s()["postseason"]["my_team_id"] = team_id
-    validate_game_state(_s())
+    def _impl(gs: dict) -> None:
+        gs["postseason"]["my_team_id"] = team_id
+
+    _mutate_state("postseason_set_my_team_id", _impl)
 
 
 def postseason_set_dates(play_in_start, play_in_end, playoffs_start) -> None:
-    _s()["postseason"]["play_in_start_date"] = play_in_start
-    _s()["postseason"]["play_in_end_date"] = play_in_end
-    _s()["postseason"]["playoffs_start_date"] = playoffs_start
-    validate_game_state(_s())
+    def _impl(gs: dict) -> None:
+        gs["postseason"]["play_in_start_date"] = play_in_start
+        gs["postseason"]["play_in_end_date"] = play_in_end
+        gs["postseason"]["playoffs_start_date"] = playoffs_start
+
+    _mutate_state("postseason_set_dates", _impl)
 
 
 def postseason_reset() -> None:
-    _s()["postseason"] = {
-        "field": None,
-        "play_in": None,
-        "playoffs": None,
-        "champion": None,
-        "my_team_id": None,
-        "play_in_start_date": None,
-        "play_in_end_date": None,
-        "playoffs_start_date": None,
-    }
-    validate_game_state(_s())
+    def _impl(gs: dict) -> None:
+        gs["postseason"] = {
+            "field": None,
+            "play_in": None,
+            "playoffs": None,
+            "champion": None,
+            "my_team_id": None,
+            "play_in_start_date": None,
+            "play_in_end_date": None,
+            "playoffs_start_date": None,
+        }
+
+    _mutate_state("postseason_reset", _impl)
 
 
 def get_cached_stats_snapshot() -> dict:
-    return deepcopy(_s()["cached_views"]["stats"])
+    return _read_state(lambda v: _to_plain(v["cached_views"]["stats"]))
 
 
 def set_cached_stats_snapshot(stats_cache: dict) -> None:
-    _s()["cached_views"]["stats"] = deepcopy(stats_cache)
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state["cached_views"]["stats"] = deepcopy(stats_cache)
+
+    _mutate_state("set_cached_stats_snapshot", _impl)
 
 
 def get_cached_weekly_news_snapshot() -> dict:
-    return deepcopy(_s()["cached_views"]["weekly_news"])
+    return _read_state(lambda v: _to_plain(v["cached_views"]["weekly_news"]))
 
 
 def set_cached_weekly_news_snapshot(cache: dict) -> None:
-    _s()["cached_views"]["weekly_news"] = deepcopy(cache)
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state["cached_views"]["weekly_news"] = deepcopy(cache)
+
+    _mutate_state("set_cached_weekly_news_snapshot", _impl)
 
 
 def get_cached_playoff_news_snapshot() -> dict:
-    return deepcopy(_s()["cached_views"]["playoff_news"])
+    return _read_state(lambda v: _to_plain(v["cached_views"]["playoff_news"]))
 
 
 def set_cached_playoff_news_snapshot(cache: dict) -> None:
-    _s()["cached_views"]["playoff_news"] = deepcopy(cache)
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state["cached_views"]["playoff_news"] = deepcopy(cache)
+
+    _mutate_state("set_cached_playoff_news_snapshot", _impl)
 
 
 def export_trade_context_snapshot() -> dict:
-    return deepcopy(
-        {
-            "players": _s()["players"],
-            "teams": _s()["teams"],
-            "asset_locks": _s()["asset_locks"],
-            "league": get_league_context_snapshot(),
-            "my_team_id": _s()["postseason"]["my_team_id"],
-        }
-    )
+    def _impl(v: Mapping[str, Any]) -> dict:
+        return {
+            "players": _to_plain(v.get("players") or {}),
+            "teams": _to_plain(v.get("teams") or {}),
+            "asset_locks": _to_plain(v.get("asset_locks") or {}),
+            "league": get_league_context_snapshot(),
+            "my_team_id": v["postseason"]["my_team_id"],
+        }
+
+    return _read_state(_impl)
@@ -577,172 +712,340 @@ def export_trade_assets_snapshot() -> dict:
     with LeagueRepo(get_db_path()) as repo:
         return deepcopy(repo.get_trade_assets_snapshot() or {})
 
 
 def ensure_cap_model_populated_if_needed() -> None:
     from state_modules import state_bootstrap
 
-    state_bootstrap.ensure_cap_model_populated_if_needed(_s())
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state_bootstrap.ensure_cap_model_populated_if_needed(state)
+
+    _mutate_state("ensure_cap_model_populated_if_needed", _impl)
 
 
 def ensure_player_ids_normalized(*, allow_legacy_numeric: bool = True) -> dict:
     from state_modules import state_bootstrap
 
-    report = state_bootstrap.ensure_player_ids_normalized(_s(), allow_legacy_numeric=allow_legacy_numeric)
-    validate_game_state(_s())
-    return report
+    def _impl(state: dict) -> dict:
+        return state_bootstrap.ensure_player_ids_normalized(state, allow_legacy_numeric=allow_legacy_numeric)
+
+    return _mutate_state("ensure_player_ids_normalized", _impl)
 
 
 def ensure_trade_state_keys() -> None:
     from state_modules import state_trade
 
-    state_trade.ensure_trade_state_keys(_s())
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state_trade.ensure_trade_state_keys(state)
+
+    _mutate_state("ensure_trade_state_keys", _impl)
 
 
 def trade_agreements_get() -> dict:
-    return deepcopy(_s().get("trade_agreements") or {})
+    return _read_state(lambda v: _to_plain(v.get("trade_agreements") or {}))
 
 
 def trade_agreements_set(value: dict) -> None:
-    _s()["trade_agreements"] = deepcopy(value)
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state["trade_agreements"] = deepcopy(value)
+
+    _mutate_state("trade_agreements_set", _impl)
 
 
 def asset_locks_get() -> dict:
-    return deepcopy(_s().get("asset_locks") or {})
+    return _read_state(lambda v: _to_plain(v.get("asset_locks") or {}))
 
 
 def asset_locks_set(value: dict) -> None:
-    _s()["asset_locks"] = deepcopy(value)
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state["asset_locks"] = deepcopy(value)
+
+    _mutate_state("asset_locks_set", _impl)
 
 
 def negotiations_get() -> dict:
-    with _NEGOTIATIONS_LOCK:
-        return deepcopy(_s().get("negotiations") or {})
+    def _impl(v: Mapping[str, Any]) -> dict:
+        with _NEGOTIATIONS_LOCK:
+            return _to_plain(v.get("negotiations") or {})
+
+    return _read_state(_impl)
 
 
 def negotiations_set(value: dict) -> None:
-    with _NEGOTIATIONS_LOCK:
-        _s()["negotiations"] = deepcopy(value)
-        validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        with _NEGOTIATIONS_LOCK:
+            state["negotiations"] = deepcopy(value)
+
+    _mutate_state("negotiations_set", _impl)
 
 
 def negotiation_session_get(session_id: str) -> Optional[dict]:
     """Return a snapshot (deep copy) of one negotiation session, or None."""
-    with _NEGOTIATIONS_LOCK:
-        negotiations = _s().get("negotiations") or {}
-        session = negotiations.get(session_id)
-        return deepcopy(session) if session is not None else None
+    def _impl(v: Mapping[str, Any]) -> Optional[dict]:
+        with _NEGOTIATIONS_LOCK:
+            negotiations = v.get("negotiations") or {}
+            session = negotiations.get(session_id) if hasattr(negotiations, "get") else None
+            return _to_plain(session) if session is not None else None
+
+    return _read_state(_impl)
 
 
 def negotiation_session_put(session_id: str, session: dict) -> None:
     """Upsert one negotiation session (deep-copied) and validate."""
-    with _NEGOTIATIONS_LOCK:
-        negotiations = _s().setdefault("negotiations", {})
-        negotiations[session_id] = deepcopy(session)
-        validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        with _NEGOTIATIONS_LOCK:
+            negotiations = state.setdefault("negotiations", {})
+            negotiations[session_id] = deepcopy(session)
+
+    _mutate_state("negotiation_session_put", _impl)
 
 
 def negotiation_session_update(session_id: str, mutator: Callable[[dict], None]) -> dict:
     """Atomically read-modify-write a single session under lock and validate.
 
     Raises KeyError if the session_id does not exist.
     Returns a snapshot (deep copy) of the updated session.
     """
-    with _NEGOTIATIONS_LOCK:
-        negotiations = _s().setdefault("negotiations", {})
-        if session_id not in negotiations:
-            raise KeyError(session_id)
-
-        working = deepcopy(negotiations[session_id])
-        mutator(working)
-        negotiations[session_id] = working
-        validate_game_state(_s())
-        return deepcopy(working)
+    def _impl(state: dict) -> dict:
+        with _NEGOTIATIONS_LOCK:
+            negotiations = state.setdefault("negotiations", {})
+            if session_id not in negotiations:
+                raise KeyError(session_id)
+
+            working = deepcopy(negotiations[session_id])
+            mutator(working)
+            negotiations[session_id] = working
+            return deepcopy(working)
+
+    return _mutate_state("negotiation_session_update", _impl)
 
 
 def trade_market_get() -> dict:
-    return deepcopy(_s().get("trade_market") or {})
+    return _read_state(lambda v: _to_plain(v.get("trade_market") or {}))
 
 
 def trade_market_set(value: dict) -> None:
-    _s()["trade_market"] = deepcopy(value)
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state["trade_market"] = deepcopy(value)
+
+    _mutate_state("trade_market_set", _impl)
 
 
 def trade_memory_get() -> dict:
-    return deepcopy(_s().get("trade_memory") or {})
+    return _read_state(lambda v: _to_plain(v.get("trade_memory") or {}))
 
 
 def trade_memory_set(value: dict) -> None:
-    _s()["trade_memory"] = deepcopy(value)
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state["trade_memory"] = deepcopy(value)
+
+    _mutate_state("trade_memory_set", _impl)
 
 
 def players_get() -> dict:
-    return deepcopy(_s().get("players") or {})
+    return _read_state(lambda v: _to_plain(v.get("players") or {}))
 
 
 def players_set(value: dict) -> None:
-    _s()["players"] = deepcopy(value)
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state["players"] = deepcopy(value)
+
+    _mutate_state("players_set", _impl)
 
 
 def teams_get() -> dict:
-    return deepcopy(_s().get("teams") or {})
+    return _read_state(lambda v: _to_plain(v.get("teams") or {}))
 
 
 def teams_set(value: dict) -> None:
-    _s()["teams"] = deepcopy(value)
-    validate_game_state(_s())
+    def _impl(state: dict) -> None:
+        state["teams"] = deepcopy(value)
+
+    _mutate_state("teams_set", _impl)
 
 
 def reset_state_for_dev() -> None:
     _reset_state_for_dev()
+
+
+# ---- Remaining read APIs rewritten to avoid global dict exposure ----
+
+
+def export_workflow_state(
+    exclude_keys: tuple[str, ...] = (
+        "draft_picks",
+        "swap_rights",
+        "fixed_assets",
+        "transactions",
+        "contracts",
+        "player_contracts",
+        "active_contract_id_by_player",
+        "free_agents",
+        "gm_profiles",
+    ),
+) -> dict:
+    snapshot = snapshot_state()
+    for key in exclude_keys:
+        snapshot.pop(key, None)
+    return snapshot
+
+
+def export_full_state_snapshot() -> dict:
+    return snapshot_state()
+
+
+def get_current_date() -> str | None:
+    return _read_state(lambda v: v["league"]["current_date"])
+
+
+def get_current_date_as_date():
+    def _impl(v: Mapping[str, Any]):
+        league = v["league"]
+        current_date = league.get("current_date") if hasattr(league, "get") else None
+        if current_date:
+            try:
+                return date.fromisoformat(str(current_date))
+            except ValueError:
+                pass
+        season_start = league.get("season_start") if hasattr(league, "get") else None
+        if season_start:
+            try:
+                return date.fromisoformat(str(season_start))
+            except ValueError:
+                pass
+        return date.today()
+
+    return _read_state(_impl)
+
+
+def set_current_date(date_str: str | None) -> None:
+    def _impl(state: dict) -> None:
+        state["league"]["current_date"] = date_str
+
+    _mutate_state("set_current_date", _impl)
+
+
+def get_db_path() -> str:
+    def _impl(v: Mapping[str, Any]) -> str:
+        league = v.get("league") or {}
+        db_path = league.get("db_path") if hasattr(league, "get") else None
+        return str(db_path or "league.db")
+
+    return _read_state(_impl)
+
+
+def set_db_path(path: str) -> None:
+    def _impl(state: dict) -> None:
+        state["league"]["db_path"] = str(path)
+
+    _mutate_state("set_db_path", _impl)
+
+
+def set_last_gm_tick_date(date_str: str | None) -> None:
+    def _impl(state: dict) -> None:
+        state["league"]["last_gm_tick_date"] = date_str
+
+    _mutate_state("set_last_gm_tick_date", _impl)
+
+
+def get_league_context_snapshot() -> dict:
+    def _impl(v: Mapping[str, Any]) -> dict:
+        league = v["league"]
+        trade_rules = league.get("trade_rules") if hasattr(league, "get") else {}
+        return {
+            "season_year": league["season_year"],
+            "trade_rules": _to_plain(trade_rules),
+            "current_date": league["current_date"],
+            "season_start": league["season_start"],
+        }
+
+    return _read_state(_impl)
+
+
+def initialize_master_schedule_if_needed(force: bool = False) -> None:
+    ensure_schedule_for_active_season(force=force)
+
+
+def get_schedule_summary() -> dict:
+    from state_modules import state_schedule
+
+    ensure_schedule_for_active_season(force=False)
+
+    def _impl(v: Mapping[str, Any]) -> dict:
+        ms_plain = _to_plain(v["league"]["master_schedule"])
+        return state_schedule.get_schedule_summary(ms_plain)
+
+    return _read_state(_impl)
+
+
+def get_active_season_id() -> str | None:
+    return _read_state(lambda v: v.get("active_season_id"))
+
+
+def set_active_season_id(next_season_id: str) -> None:
+    def _impl(state: dict) -> None:
+        old = state.get("active_season_id")
+        if old is not None:
+            state["season_history"][str(old)] = {
+                "regular": deepcopy(
+                    {
+                        "games": state["games"],
+                        "player_stats": state["player_stats"],
+                        "team_stats": state["team_stats"],
+                        "game_results": state["game_results"],
+                    }
+                ),
+                "phase_results": deepcopy(state["phase_results"]),
+                "postseason": deepcopy(state["postseason"]),
+                "archived_at_turn": int(state["turn"]),
+                "archived_at_date": state["league"]["current_date"],
+            }
+        state["games"] = []
+        state["player_stats"] = {}
+        state["team_stats"] = {}
+        state["game_results"] = {}
+        state["phase_results"] = {
+            "preseason": {"games": [], "player_stats": {}, "team_stats": {}, "game_results": {}},
+            "play_in": {"games": [], "player_stats": {}, "team_stats": {}, "game_results": {}},
+            "playoffs": {"games": [], "player_stats": {}, "team_stats": {}, "game_results": {}},
+        }
+        state["postseason"] = {
+            "field": None,
+            "play_in": None,
+            "playoffs": None,
+            "champion": None,
+            "my_team_id": None,
+            "play_in_start_date": None,
+            "play_in_end_date": None,
+            "playoffs_start_date": None,
+        }
+        state["active_season_id"] = str(next_season_id)
+        state["cached_views"] = {
+            "scores": {"latest_date": None, "games": []},
+            "schedule": {"teams": {}},
+            "stats": {"leaders": None},
+            "weekly_news": {"last_generated_week_start": None, "items": []},
+            "playoff_news": {"series_game_counts": {}, "items": []},
+            "_meta": {
+                "scores": {"built_from_turn": -1, "season_id": None},
+                "schedule": {"built_from_turn_by_team": {}, "season_id": None},
+            },
+        }
+
+        next_year = _season_year_from_season_id(str(next_season_id))
+        state["league"]["season_year"] = int(next_year)
+        state["league"]["draft_year"] = int(next_year) + 1
+
+        _clear_master_schedule(state["league"])
+
+    _mutate_state("set_active_season_id", _impl)
